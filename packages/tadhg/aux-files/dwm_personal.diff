diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/config.def.h /home/tadhg/src/dwm/config.def.h
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/config.def.h	1969-12-31 19:00:01.000000000 -0500
+++ /home/tadhg/src/dwm/config.def.h	2025-09-18 18:54:29.849478536 -0400
@@ -1,12 +1,13 @@
 /* See LICENSE file for copyright and license details. */
-
+#include <X11/XF86keysym.h>
 /* appearance */
-static const unsigned int borderpx  = 1;        /* border pixel of windows */
+static const unsigned int borderpx  = 2;        /* border pixel of windows */
 static const unsigned int snap      = 32;       /* snap pixel */
-static const int showbar            = 1;        /* 0 means no bar */
+// showbar=2 means it starts in the state like you are holding down the mod key, so showing but will go away when you do anything
+static const int showbar            = 2;        /* 0 means no bar */
 static const int topbar             = 1;        /* 0 means bottom bar */
-static const char font[]            = "monospace 10";
-static const char dmenufont[]       = "monospace:size=10";
+static const char font[]            = "monospace 16";
+static const char dmenufont[]       = "monospace:size=16";
 static const char col_gray1[]       = "#222222";
 static const char col_gray2[]       = "#444444";
 static const char col_gray3[]       = "#bbbbbb";
@@ -16,19 +17,30 @@ static const char *colors[][3]      = {
 	/*               fg         bg         border   */
 	[SchemeNorm] = { col_gray3, col_gray1, col_gray2 },
 	[SchemeSel]  = { col_gray4, col_cyan,  col_cyan  },
+	[SchemeFade] = { col_gray2, col_gray1, col_gray1 },
 };
 
 /* tagging */
-static const char *tags[] = { "1", "2", "3", "4", "5", "6", "7", "8", "9" };
-
+// these are intended to be the dozonal characters I define with my custom font.
+// without the custom font they are the unicode characters for "Ideographic Telegraph Symbol For Hour X" where X goes from 0 to 11.
+// so in theory a font that supports this range would display reasonable graphics for the tags.
+static const char *tags[] = { "\u3358", "\u3359", "\u335a", "\u335b", "\u335c", "\u335d", "\u335e", "\u335f", "\u3360", "\u3361", "\u3362", "\u3363" };
+
+// rules to apply to new windows, can force them to start on a particular tag or to be floating or a monitor etc.
+// currently if a program is launched while the auto-start programs are still being opened it breaks the sequence
+// putting all the windows to the wrong spots, we could use rules to fix that but it would mean that if we, say,
+// opened emacs at any point like to view a file it would always open on tag 3 if we specified it here.
+// so I think the current system where the auto-start specifies the tag and this is used only to fix issues with splash screen
+// that is the best bet.
+// also use `guix shell xprop -- xprop` then click on a window to print the details,
 static const Rule rules[] = {
 	/* xprop(1):
 	 *	WM_CLASS(STRING) = instance, class
 	 *	WM_NAME(STRING) = title
 	 */
 	/* class      instance    title       tags mask     isfloating   monitor */
-	{ "Gimp",     NULL,       NULL,       0,            1,           -1 },
-	{ "Firefox",  NULL,       NULL,       1 << 8,       0,           -1 },
+        // force discord to open on tag 1 since it has the annoying splash screen
+	{ "discord",  "discord",  NULL,       1 << 1,       0,           -1 },
 };
 
 /* layout(s) */
@@ -37,99 +49,234 @@ static const int nmaster     = 1;    /*
 static const int resizehints = 1;    /* 1 means respect size hints in tiled resizals */
 static const int lockfullscreen = 1; /* 1 will force focus on the fullscreen window */
 
+/** w/h ratio  */
+static const float MIN_ASPECT_RATIO_TO_TILE_HORIZONTALLY = 1.0;
+/** amount of space used by 'fullscreen' apps in tiling function */
+static const float SHRINK_FACTOR_FOR_FULLSCREEN = 0.98;
+/** wrapper for real resize that takes the space in dwm layout and resizes window to account for border
+ effectively this takes the w and h that you'd want WIDTH(c) and HEIGHT(c) to resolve to. */
+void myresize(Client *c, int x, int y, int w, int h){
+  // personally I feel like dwm should be setup so the border is
+  // accounted for in the underlying resize and make c->w variable we
+  // see contain the border so we don't have to think about it in our
+  // tiling functions
+  unsigned int bw = 2*c->bw;
+  // the 0 as last argument is for "interactive", 0 when using a tiling
+  // function and 1 when the user is interactively resizing a floating window
+  resize(c, x, y, w - bw, h - bw, 0);
+}
+void mytile(Monitor *m){
+  // c is the next client to place
+  Client *c = nexttiled(m->clients);
+  if(c==NULL){ return; }// there are no visible non floating clients, nothing to do.
+  // x and y are the anchor point for the next client to tile
+  unsigned int x = m->wx;
+  unsigned int y = m->wy;
+  // w and h are the space we have to place more windows
+  unsigned int w = m->ww;
+  unsigned int h = m->wh;
+  // the shrinking factor
+  float normal_shrink_factor = m->mfact;
+  while(1){ // broken by nextc==NULL in the middle of the loop
+    float mfact = c->isfullscreen ? SHRINK_FACTOR_FOR_FULLSCREEN : normal_shrink_factor;
+    Client *nextc = nexttiled(c->next);
+    if(nextc == NULL || (c->mina != 0 && c->maxa != 0)){
+      // last one to tile or desired aspect ratio, use up all the available space
+      myresize(c, x, y, w,h);
+    } else if(w > h*MIN_ASPECT_RATIO_TO_TILE_HORIZONTALLY){
+      // w/h > target, so use up fraction of width (tile horizontally)
+      myresize(c, x,y, w*mfact, h);
+    } else { // tile vertically
+      myresize(c, x,y, w, h*mfact);
+    }
+    
+    if(nextc == NULL){
+      return; // we've positioned the last client so we are done.
+    }
+    // because of aspect ratio and border widths just check whether there is more space vertically or horizontally to tile next elements.
+    // Note: this assumes vertical and horizontal borders are identical which may not be true with patches,
+    //   replace c->w with WIDTH(c) and c->h with HEIGHT(c) if this is a concern.
+    // TODO: casting these to ints fixes the issue if one ends up negative but is it the correct way to handle this?
+    if((int)(w - c->w) > (int)(h - c->h)){
+      // more space to the side
+      w -= c->w + 2*c->bw;
+      x += c->w + 2*c->bw;
+    } else {
+      // more space below
+      h -= c->h + 2*c->bw;
+      y += c->h + 2*c->bw;
+      // TODO move this function to dwm.c so I can use WIDTH and HEIGHT macros instead of explicitly adding 2*c->bw 
+    }
+    c = nextc;
+  }
+}
+
 static const Layout layouts[] = {
 	/* symbol     arrange function */
-	{ "[]=",      tile },    /* first entry is default */
+	{ "Tad",      mytile },    /* first entry is default */
 	{ "><>",      NULL },    /* no layout function means floating behavior */
 	{ "[M]",      monocle },
-	{ "TTT",      bstack },
+	{ "[]=",      tile },
 	{ "===",      bstackhoriz },
 };
 
 /* key definitions */
-#define MODKEY Mod1Mask
+#define MODKEY Mod4Mask
 #define TAGKEYS(KEY,TAG) \
 	{ MODKEY,                       KEY,      view,           {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask,           KEY,      toggleview,     {.ui = 1 << TAG} }, \
 	{ MODKEY|ShiftMask,             KEY,      tag,            {.ui = 1 << TAG} }, \
 	{ MODKEY|ControlMask|ShiftMask, KEY,      toggletag,      {.ui = 1 << TAG} },
-#define HOLDKEY 0xffe9 // 0 - disable; 0xffe9 - Mod1Mask; 0xffeb - Mod4Mask
+#define HOLDKEY 0xffeb // 0 - disable; 0xffe9 - Mod1Mask; 0xffeb - Mod4Mask
+#define HYPERKEY 0xffee
 
 /* helper for spawning shell commands in the pre dwm-5.0 fashion */
 #define SHCMD(cmd) { .v = (const char*[]){ "/bin/sh", "-c", cmd, NULL } }
 
 /* commands */
-static const char *dmenucmd[] = { "dmenu_run", "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
-static const char *termcmd[]  = { "st", NULL };
 
-static const char *termcmd2[] = { "xterm", NULL };
-static const char *browsercmd[] = {"librewolf", NULL};
-static const char *keepassxccmd[] = {"keepassxc", NULL};
-static const char *emacscmd[] = {"emacs", NULL};
+static const char *dmenucmd[] = { "dmenuwithbangs", "-fn", dmenufont, "-nb", col_gray1, "-nf", col_gray3, "-sb", col_cyan, "-sf", col_gray4, NULL };
+static const char *termcmd[]  = { "alacritty", NULL };
+static const char *chatclientcmd[] = { "dino", NULL };
+static const char *discord[] = {"discord", NULL};
+//static const char *fbmessengerbrave[] = {"brave", "--app=https://www.messenger.com/", NULL};
+//static const char *signalchatcmd[] = {"signal-desktop", NULL};
+static const char *browsercmd[] = {"brave", NULL};
+static const char *emailclientcmd[] = {"icedove", NULL};
+static const char *emacscmd[] = {"emacsclient", "--no-wait", "--create-frame", "--timeout=1", NULL};
+static const char *insertemoji[] = {"insert-emoji", NULL};
 
 Autostarttag autostarttaglist[] = {
-	{.cmd = browsercmd, .tags = 1 << 0 },
-	{.cmd = keepassxccmd, .tags = 1 << 4 },
-	{.cmd = emacscmd, .tags = 1 << 7 },
-	{.cmd = termcmd2, .tags = 1 << 8 },
-	{.cmd = NULL, .tags = 0 },
+	// start with apps that consistently only open one window to minimize the chance of messing up sequence
+  { .tags=1<< 5, .cmd=emailclientcmd },
+  //{ .tags=1<< 1, .cmd=signalchatcmd },
+  { .tags=1<< 1, .cmd=chatclientcmd },
+  // this command consistently opens one window but emacs daemon it depends on can be delayed a bit.
+  //{ .tags=1<< 3, .cmd=emacscmd }, // emacsclient fails if emacs takes too long to open
+  // discord opens a splash screen which can mess up sequencing
+  { .tags=1<< 1, .cmd=discord },
+  // if multiple windows were open and it shut down properly (uncommon with my setup) it can reopen several windows
+  { .tags=1<< 2, .cmd=browsercmd },
+
+    {.cmd = NULL, .tags = 0 }
 };
 
+
 static const Key keys[] = {
 	/* modifier                     key        function        argument */
-	{ MODKEY,                       XK_p,      spawn,          {.v = dmenucmd } },
-	{ MODKEY|ShiftMask,             XK_Return, spawn,          {.v = termcmd } },
-	{ MODKEY,                       XK_b,      togglebar,      {0} },
-	{ MODKEY,                       XK_j,      focusstack,     {.i = +1 } },
-	{ MODKEY,                       XK_k,      focusstack,     {.i = -1 } },
-	{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },
-	{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },
+        // win+space opens dmenu for quicklook like behaviour
+	{ MODKEY,                       XK_space,             spawn, {.v = dmenucmd } },
+	// win+shift+space opens terminal
+	{ MODKEY|ShiftMask,             XK_space,             spawn, {.v = termcmd } },
+	// win+n opens a new emacs frame
+	{ MODKEY,                       XK_n,                 spawn, {.v = emacscmd } },
+	// TODO: probably remove this, win+play_pause speaks the selected text
+	{ MODKEY,                       XF86XK_AudioPlay,           spawn, SHCMD("xclip -o | festival --tts") },
+	{ MODKEY,                       XK_v,                spawn, { .v = insertemoji } },
+	// brightness keys, shift+win goes to extreme value, win goes to major value and without modifier keys goes to typical value
+	// TODO: implement deltas into brctl and add bindings here instead of always absolute.
+	// every now and then the brightness keys stop working so map the function keys too as a backup
+	{ MODKEY|ShiftMask,             XF86XK_MonBrightnessDown,   spawn, SHCMD("brctl 0") },
+	{ MODKEY|ShiftMask,             XK_F7,                      spawn, SHCMD("brctl 0") },
+	{ MODKEY,                       XF86XK_MonBrightnessDown,   spawn, SHCMD("brctl 1") },
+	{ MODKEY,                       XK_F7,                      spawn, SHCMD("brctl 1") },
+	{ 0,                            XF86XK_MonBrightnessDown,   spawn, SHCMD("brctl 5") },
+	{ 0,                            XK_F7,                      spawn, SHCMD("brctl 5") },
+	{ 0,                            XF86XK_MonBrightnessUp,     spawn, SHCMD("brctl 10") },
+	{ 0,                            XK_F8,                      spawn, SHCMD("brctl 10") },
+	{ MODKEY,                       XF86XK_MonBrightnessUp,     spawn, SHCMD("brctl 20") },
+	{ MODKEY,                       XK_F8,                      spawn, SHCMD("brctl 20") },
+	{ MODKEY|ShiftMask,             XF86XK_MonBrightnessUp,     spawn, SHCMD("brctl 40") },
+	{ MODKEY|ShiftMask,             XK_F8,                      spawn, SHCMD("brctl 40") },
+	// mute button: without modkey unconditional unmute, with modkey unconditional mute
+	{ 0,                            XF86XK_AudioMute,           spawn, SHCMD("amixer set Master mute") },
+	{ MODKEY,                       XF86XK_AudioMute,           spawn, SHCMD("amixer set Master unmute") },
+	// volume down: (without modkey decreases volume by 5%, with modkey sets volume to 0
+	{ 0,                            XF86XK_AudioLowerVolume,    spawn, SHCMD("amixer set Master 5%-") },
+	{ MODKEY,                       XF86XK_AudioLowerVolume,    spawn, SHCMD("amixer set Master 0%") },
+	// volume up: withoutt modkey increases 5%, with modkey increases 5% with pactl so it can go above 100%
+	{ 0,                            XF86XK_AudioRaiseVolume,    spawn, SHCMD("amixer set Master 5%+") },
+	{ MODKEY,                       XF86XK_AudioRaiseVolume,    spawn, SHCMD("pactl set-sink-volume 0 +5%") },
+	// don't allow toggling the bar to always be showing because I don't typically want that.
+	/*{ MODKEY,                       XK_b,      togglebar,      {0} },*/
+	// use layouts instead of being able to increment nmaster
+	/*{ MODKEY,                       XK_i,      incnmaster,     {.i = +1 } },*/
+	/*{ MODKEY,                       XK_d,      incnmaster,     {.i = -1 } },*/
+	// h and l change the size of the main window when there are more than 1 window open in the tag.
 	{ MODKEY,                       XK_h,      setmfact,       {.f = -0.05} },
 	{ MODKEY,                       XK_l,      setmfact,       {.f = +0.05} },
+	// return key (enter) sets the selected window as the main one (moves to left larger space) only noticable with 3 windows open on a tag.
 	{ MODKEY,                       XK_Return, zoom,           {0} },
-	{ MODKEY,                       XK_Tab,    view,           {0} },
-	{ MODKEY|ShiftMask,             XK_c,      killclient,     {0} },
+	// win+tab will toggle between recently used tags
+        { MODKEY,                       XK_Tab,    view,           {0} },
+	// backspace kills the selected window, if no windows are open in any tag this will also close dwm (which is one of my personal edits to the code)
+	{ MODKEY,                       XK_BackSpace,      killclient,     {0} },
+	// force quit dwm and all windows.
+	{ MODKEY|ShiftMask|ControlMask, XK_BackSpace,      quit,           {0} },
+	// clicking on tile symbol in menu bar switches between the only layouts I care about.
 	{ MODKEY,                       XK_t,      setlayout,      {.v = &layouts[0]} },
-	{ MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },
-	{ MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },
+	/* { MODKEY,                       XK_f,      setlayout,      {.v = &layouts[1]} },*/
+	/* { MODKEY,                       XK_m,      setlayout,      {.v = &layouts[2]} },*/
 	{ MODKEY,                       XK_u,      setlayout,      {.v = &layouts[3]} },
-	{ MODKEY,                       XK_o,      setlayout,      {.v = &layouts[4]} },
-	{ MODKEY,                       XK_space,  setlayout,      {0} },
-	{ MODKEY|ShiftMask,             XK_space,  togglefloating, {0} },
-	{ MODKEY|ShiftMask,             XK_f,      togglefullscr,  {0} },
-	{ MODKEY,                       XK_0,      view,           {.ui = ~0 } },
-	{ MODKEY|ShiftMask,             XK_0,      tag,            {.ui = ~0 } },
+	/* { MODKEY,                       XK_o,      setlayout,      {.v = &layouts[4]} },*/
+	/*{ MODKEY,                       XK_space,  setlayout,      {0} },*/
+	{ MODKEY|ShiftMask|ControlMask, XK_f,      togglefloating, {0} },
+	{ MODKEY,                       XK_f,      togglefullscr,  {0} },
+	// comma and period change focus between monitors, shift+win+comma moves the window to another monitor etc.
 	{ MODKEY,                       XK_comma,  focusmon,       {.i = -1 } },
 	{ MODKEY,                       XK_period, focusmon,       {.i = +1 } },
 	{ MODKEY|ShiftMask,             XK_comma,  tagmon,         {.i = -1 } },
 	{ MODKEY|ShiftMask,             XK_period, tagmon,         {.i = +1 } },
-	TAGKEYS(                        XK_1,                      0)
-	TAGKEYS(                        XK_2,                      1)
-	TAGKEYS(                        XK_3,                      2)
-	TAGKEYS(                        XK_4,                      3)
-	TAGKEYS(                        XK_5,                      4)
-	TAGKEYS(                        XK_6,                      5)
-	TAGKEYS(                        XK_7,                      6)
-	TAGKEYS(                        XK_8,                      7)
-	TAGKEYS(                        XK_9,                      8)
-	{ MODKEY|ShiftMask,             XK_q,      quit,           {0} },
-	{ 0,                            HOLDKEY,   holdbar,        {0} },
+	// tagkeys, starting from grave for 0, 1 to 9 then 0=>10 and minus=>11.
+	TAGKEYS(                        XK_grave,                   0)
+	TAGKEYS(                        XK_1,                       1)
+	TAGKEYS(                        XK_2,                       2)
+	TAGKEYS(                        XK_3,                       3)
+	TAGKEYS(                        XK_4,                       4)
+	TAGKEYS(                        XK_5,                       5)
+	TAGKEYS(                        XK_6,                       6)
+	TAGKEYS(                        XK_7,                       7)
+	TAGKEYS(                        XK_8,                       8)
+	TAGKEYS(                        XK_9,                       9)
+	TAGKEYS(                        XK_0,                      10)
+	TAGKEYS(                        XK_minus,                  11)
+	// use equal key as 'all tags', so win+equal shows all windows and win+shift+equal sets a window to be visible on all tags
+	{ MODKEY,                       XK_equal,      view,           {.ui = ~0 } },
+	{ MODKEY|ShiftMask,             XK_equal,      tag,            {.ui = ~0 } },
+	// pressing the win key with any other modifiers should show the bar,
+        // in theory this could be handled as a special case in the code to ignore modifiers if the key is HOLDKEY but this works too.
+	// TODO figure out how to make use of AnyModifier
+        { 0,                            HOLDKEY,   holdbar,        {0} },
+        { ShiftMask,                    HOLDKEY,   holdbar,        {0} },
+        { ControlMask,                  HOLDKEY,   holdbar,        {0} },
+        { ShiftMask|ControlMask,        HOLDKEY,   holdbar,        {0} },
+        { Mod1Mask,                     HOLDKEY,   holdbar,        {0} },
+        { Mod1Mask|ShiftMask,           HOLDKEY,   holdbar,        {0} },
+        { Mod1Mask|ControlMask,         HOLDKEY,   holdbar,        {0} },
+        { Mod1Mask|ShiftMask|ControlMask,HOLDKEY,   holdbar,       {0} },
+	// pressing alt key disables dozonal display, keyrelease function handles reverting this
+	// I am not thrilled about dealing with holdbar and this as normal keybindings instead of both be special handling that could also
+	// ignore modifiers but this is definitely easiest way
+	{ MODKEY,                       HYPERKEY,   disabledoz,      {0} },
 };
 
 /* button definitions */
 /* click can be ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle, ClkClientWin, or ClkRootWin */
+/* note all are set to use MODKEY because the bar will only show up when the mod key is held */
 static const Button buttons[] = {
 	/* click                event mask      button          function        argument */
-	{ ClkLtSymbol,          0,              Button1,        setlayout,      {0} },
-	{ ClkLtSymbol,          0,              Button3,        setlayout,      {.v = &layouts[2]} },
-	{ ClkWinTitle,          0,              Button2,        zoom,           {0} },
-	{ ClkStatusText,        0,              Button2,        spawn,          {.v = termcmd } },
-	{ ClkClientWin,         MODKEY,         Button1,        movemouse,      {0} },
-	{ ClkClientWin,         MODKEY,         Button2,        togglefloating, {0} },
-	{ ClkClientWin,         MODKEY,         Button3,        resizemouse,    {0} },
-	{ ClkTagBar,            0,              Button1,        view,           {0} },
-	{ ClkTagBar,            0,              Button3,        toggleview,     {0} },
-	{ ClkTagBar,            MODKEY,         Button1,        tag,            {0} },
-	{ ClkTagBar,            MODKEY,         Button3,        toggletag,      {0} },
+  // clicking on layout symbol switches to tiling, rightclick switches to list mode
+	{ ClkLtSymbol,          MODKEY,              Button1,        setlayout,      {.v = &layouts[0]} },
+        { ClkLtSymbol,          MODKEY,              Button3,        setlayout,      {.v = &layouts[3]} },
+	{ ClkWinTitle,          MODKEY,              Button2,        zoom,           {0} },
+	//{ ClkStatusText,        MODKEY,              Button1,        toggledoz,     {0} },
+	{ ClkStatusText,        MODKEY,              Button2,        spawn,          {.v = termcmd } },
+	{ ClkClientWin,         MODKEY|ShiftMask,         Button1,        movemouse,      {0} },
+	{ ClkClientWin,         MODKEY|ShiftMask,         Button2,        togglefloating, {0} },
+	{ ClkClientWin,         MODKEY|ShiftMask,         Button3,        resizemouse,    {0} },
+	{ ClkTagBar,            MODKEY,              Button1,        view,           {0} },
+	{ ClkTagBar,            MODKEY,              Button3,        toggleview,     {0} },
+	{ ClkTagBar,            MODKEY|ShiftMask,         Button1,        tag,            {0} },
+	{ ClkTagBar,            MODKEY|ShiftMask,         Button3,        toggletag,      {0} },
 };
 
diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/config.mk /home/tadhg/src/dwm/config.mk
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/config.mk	1969-12-31 19:00:01.000000000 -0500
+++ /home/tadhg/src/dwm/config.mk	2025-06-23 17:26:38.303124679 -0400
@@ -36,4 +36,4 @@ LDFLAGS  = ${LIBS}
 #LDFLAGS = ${LIBS}
 
 # compiler and linker
-CC = cc
+CC = gcc
diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/dwm.c /home/tadhg/src/dwm/dwm.c
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/dwm.c	1969-12-31 19:00:01.000000000 -0500
+++ /home/tadhg/src/dwm/dwm.c	2025-09-19 12:19:22.692345951 -0400
@@ -27,6 +27,7 @@
 #include <stdio.h>
 #include <stdlib.h>
 #include <string.h>
+#include <time.h>
 #include <unistd.h>
 #include <sys/types.h>
 #include <sys/wait.h>
@@ -44,6 +45,7 @@
 
 #include "drw.h"
 #include "util.h"
+#include "status.h"
 
 /* macros */
 #define BUTTONMASK              (ButtonPressMask|ButtonReleaseMask)
@@ -61,7 +63,7 @@
 
 /* enums */
 enum { CurNormal, CurResize, CurMove, CurLast }; /* cursor */
-enum { SchemeNorm, SchemeSel }; /* color schemes */
+enum { SchemeNorm, SchemeSel, SchemeFade }; /* color schemes */
 enum { NetSupported, NetWMName, NetWMState, NetWMCheck,
        NetWMFullscreen, NetActiveWindow, NetWMWindowType,
        NetWMWindowTypeDialog, NetClientList, NetLast }; /* EWMH atoms */
@@ -69,6 +71,10 @@ enum { WMProtocols, WMDelete, WMState, W
 enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,
        ClkClientWin, ClkRootWin, ClkLast }; /* clicks */
 
+struct timespec current_time;
+struct timespec next_update;
+int usedoz = 1;
+
 typedef union {
 	int i;
 	unsigned int ui;
@@ -223,6 +229,7 @@ static void tag(const Arg *arg);
 static void tagmon(const Arg *arg);
 static void tile(Monitor *m);
 static void togglebar(const Arg *arg);
+static void disabledoz(const Arg *arg);
 static void holdbar(const Arg *arg);
 static void togglefloating(const Arg *arg);
 static void togglefullscr(const Arg *arg);
@@ -290,6 +297,7 @@ static Window root, wmcheckwin;
 static unsigned int autostarttags = 0;
 static int autostartcomplete = 0;
 static int autostartcmdscomplete = 0;
+static Client *tadhgWM = NULL;
 
 /* configuration, allows nested code to access above variables */
 #include "config.h"
@@ -329,11 +337,17 @@ keyrelease(XEvent *e)
 			return;
 		}
 	}
-	if (e->xkey.keycode == XKeysymToKeycode(dpy, HOLDKEY) && selmon->showbar == 2) {
+	if (selmon->showbar != 2){
+	  return;
+	}
+	if(e->xkey.keycode == XKeysymToKeycode(dpy, HOLDKEY)) {
 		selmon->showbar = 0;
 		updateholdbarpos(selmon);
 		XMoveResizeWindow(dpy, selmon->barwin, selmon->wx, selmon->by, selmon->ww, bh);
 		arrange(selmon);
+	} else if (usedoz != 1 && e->xkey.keycode == XKeysymToKeycode(dpy, HYPERKEY)){
+	  usedoz = 1;
+	  updatestatus();
 	}
 }
 
@@ -508,9 +522,15 @@ buttonpress(XEvent *e)
 	}
 	if (ev->window == selmon->barwin) {
 		i = x = 0;
-		do
+		/* unsigned int occ = 0; */
+		/* for(c = m->clients; c; c=c->next) */
+		/* 	occ |= c->tags == TAGMASK ? 0 : c->tags; */
+		do {
+			/* /\* Do not reserve space for vacant tags *\/ */
+			/* if (!(occ & 1 << i || m->tagset[m->seltags] & 1 << i)) */
+			/* 	continue; */
 			x += TEXTW(tags[i]);
-		while (ev->x >= x && ++i < LENGTH(tags));
+		} while (ev->x >= x && ++i < LENGTH(tags));
 		if (i < LENGTH(tags)) {
 			click = ClkTagBar;
 			arg.ui = 1 << i;
@@ -809,17 +829,16 @@ drawbar(Monitor *m)
 	x = 0;
 	for (i = 0; i < LENGTH(tags); i++) {
 		w = TEXTW(tags[i]);
-		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : SchemeNorm]);
+		// by default tags with content get a box by them to indicate content
+		// I'd rather fade the numbers that are not in use
+		drw_setscheme(drw, scheme[m->tagset[m->seltags] & 1 << i ? SchemeSel : occ & 1 << i ? SchemeNorm : SchemeFade]);
 		drw_text(drw, x, 0, w, bh, lrpad / 2, tags[i], urg & 1 << i, False);
-		if (occ & 1 << i)
-			drw_rect(drw, x + boxs, boxs, boxw, boxw,
-				m == selmon && selmon->sel && selmon->sel->tags & 1 << i,
-				urg & 1 << i);
 		x += w;
 	}
-	w = TEXTW(m->ltsymbol);
-	drw_setscheme(drw, scheme[SchemeNorm]);
-	x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0, False);
+	// don't draw layout symbol, I've been happily using the same layout for ages.
+	/* w = TEXTW(m->ltsymbol); */
+	/* drw_setscheme(drw, scheme[SchemeNorm]); */
+	/* x = drw_text(drw, x, 0, w, bh, lrpad / 2, m->ltsymbol, 0, False); */
 
 	if ((w = m->ww - tw - x) > bh) {
 		if (m->sel) {
@@ -833,6 +852,9 @@ drawbar(Monitor *m)
 		}
 	}
 	drw_map(drw, m->barwin, 0, 0, m->ww, bh);
+	if(m->sel && m->sel->isfullscreen){
+	  XRaiseWindow(dpy, m->barwin);
+	}
 }
 
 void
@@ -1089,11 +1111,25 @@ keypress(XEvent *e)
 			keys[i].func(&(keys[i].arg));
 }
 
+int are_any_clients_running(){
+  for(Monitor* m = mons; m; m = m->next){
+    if(m->clients){
+      return 1;
+    }
+  }
+  return 0;
+}
 void
 killclient(const Arg *arg)
 {
-	if (!selmon->sel)
-		return;
+  if (!selmon->sel){
+    // if there aren't any clients running on any monitor on any tag then the keybinding to close the current window instead closes dwm
+    // this workflow gives me more reason to go close all the windows which can complain that they have unsaved data.
+    if(!are_any_clients_running()){
+      quit(arg);
+    }
+    return;
+  }
 	if (!sendevent(selmon->sel, wmatom[WMDelete])) {
 		XGrabServer(dpy);
 		XSetErrorHandler(xerrordummy);
@@ -1153,8 +1189,9 @@ manage(Window w, XWindowAttributes *wa)
 	grabbuttons(c, 0);
 	if (!c->isfloating)
 		c->isfloating = c->oldstate = trans != None || c->isfixed;
-	if (c->isfloating)
+	if (c->isfloating){
 		XRaiseWindow(dpy, c->win);
+	}
 	attach(c);
 	attachstack(c);
 	XChangeProperty(dpy, root, netatom[NetClientList], XA_WINDOW, 32, PropModeAppend,
@@ -1165,6 +1202,9 @@ manage(Window w, XWindowAttributes *wa)
 		unfocus(selmon->sel, 0);
 	c->mon->sel = c;
 	arrange(c->mon);
+	if(tadhgWM == NULL && 0==strncmp(c->name, "TadhgWM", 8)){
+	  tadhgWM = c;
+	}
 	XMapWindow(dpy, c->win);
 	focus(NULL);
 }
@@ -1185,8 +1225,15 @@ maprequest(XEvent *e)
 	static XWindowAttributes wa;
 	XMapRequestEvent *ev = &e->xmaprequest;
 
+
 	if (!XGetWindowAttributes(dpy, ev->window, &wa) || wa.override_redirect)
 		return;
+	
+	if(tadhgWM != NULL){
+	  XReparentWindow(dpy, ev->window, tadhgWM->win, 0, 0);
+	  XMapWindow(dpy, ev->window);
+	  return;
+	}
 	if (!wintoclient(ev->window))
 		manage(ev->window, &wa);
 }
@@ -1445,8 +1492,13 @@ restack(Monitor *m)
 	drawbar(m);
 	if (!m->sel)
 		return;
-	if (m->sel->isfloating || !m->lt[m->sellt]->arrange)
+	if (m->sel->isfloating || !m->lt[m->sellt]->arrange) {
 		XRaiseWindow(dpy, m->sel->win);
+		// fixed floating windows like dmenu should be able to cover the bar
+		// but if the bar is set to show and the selected window is fullscreen put the bar over it
+		if(m->showbar && m->sel->isfullscreen)
+		  XRaiseWindow(dpy, m->barwin);
+	}
 	if (m->lt[m->sellt]->arrange) {
 		wc.stack_mode = Below;
 		wc.sibling = m->barwin;
@@ -1459,14 +1511,70 @@ restack(Monitor *m)
 	XSync(dpy, False);
 	while (XCheckMaskEvent(dpy, EnterWindowMask, &ev));
 }
+/**
+  returns 1 when XNextEvent should be called, in theory it can return 0 to abort dwm but
+  the only case where we can detect something going wrong happens for expected system interrupts so
+  we just continue on that case.
+
+  If the selected monitor does not have the status bar showing this returns immidiately to wait on an event,
+  otherwise it loops until XPending or 'select' suggests there is an X event to handle.
+
+  So as long as the bar is showing and there aren't X events to handle it will get the current time,
+  measure the time delta until the next clock update, and wait that amount of time such that an X event can interrupt it.
+  This means the clock is updated as infrequently as possible while still functioning seemlessly.
+
+  In order to work properly this does rely on updatestatus() to update the variable next_update to be in the future,
+  if that wasn't the case it would continuously redraw the statusbar 
+  
+*/
+int
+update_time(int x11_fd)
+{
+  struct timeval delta;
+  // if we are not showing the bar or there are pending events just go handle the next event
+  if(!selmon->showbar) return 1;
+  while(!XPending(dpy)){
+    clock_gettime(CLOCK_REALTIME, &current_time);
+    delta.tv_sec = next_update.tv_sec - current_time.tv_sec;
+    delta.tv_usec = (next_update.tv_nsec - current_time.tv_nsec)/1000 + 1;
+    if(delta.tv_usec < 0){
+      delta.tv_sec-=1;
+      delta.tv_usec+=1e6;
+    }
+    if(delta.tv_sec < 0){
+      updatestatus(); // if we've already passed the update time (like if handling an event took a while or we had the bar hidden)
+      continue;
+    }
+    // at this point we have a valid (positive) delta to wait on the select.
+    // Create a File Description Set containing x11_fd based on:
+    // https://stackoverflow.com/a/8592969/5827215
+    fd_set in_fds;
+    FD_ZERO(&in_fds);
+    FD_SET(x11_fd, &in_fds);
+    
+    int num_ready_fds = select(x11_fd + 1, &in_fds, NULL, NULL, &delta);
+    if (num_ready_fds > 0){
+      return 1; // means there is data ready
+    } else if(num_ready_fds == 0){
+      clock_gettime(CLOCK_REALTIME, &current_time);
+      updatestatus(); // means timer expired, redraw clock and set a new timer
+      continue;
+    } else{
+      continue; // usually system interrupt or something non vital, go recheck XPending.
+      // if something has gone wrong with the select we will assume it will cause bigger issues for X and get caught there.
+    }
+  }
+  return 1;// if the loop broke it means XPending returned 1 while we were updating the clock
+}
 
 void
 run(void)
 {
 	XEvent ev;
+	int x11_fd = ConnectionNumber(dpy);
 	/* main event loop */
 	XSync(dpy, False);
-	while (running && !XNextEvent(dpy, &ev)){
+	while (running && update_time(x11_fd) && !XNextEvent(dpy, &ev)){
 		if (!(autostartcomplete || autostarttags))
 			autostarttagsspawner();
 		if (handler[ev.type])
@@ -1571,24 +1679,27 @@ setfullscreen(Client *c, int fullscreen)
 			PropModeReplace, (unsigned char*)&netatom[NetWMFullscreen], 1);
 		c->isfullscreen = 1;
 		c->oldstate = c->isfloating;
-		c->oldbw = c->bw;
-		c->bw = 0;
-		c->isfloating = 1;
-		resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh);
+		/* c->oldbw = c->bw; */
+		/* c->bw = 0; */
+		c->isfloating = 0;
+		/* resizeclient(c, c->mon->mx, c->mon->my, c->mon->mw, c->mon->mh); */
 		XRaiseWindow(dpy, c->win);
+		if(c->mon->showbar) // when an app gets set as fullscreen display the bar over it if it should be shown now
+		  XRaiseWindow(dpy, c->mon->barwin);
 	} else if (!fullscreen && c->isfullscreen){
 		XChangeProperty(dpy, c->win, netatom[NetWMState], XA_ATOM, 32,
 			PropModeReplace, (unsigned char*)0, 0);
 		c->isfullscreen = 0;
 		c->isfloating = c->oldstate;
-		c->bw = c->oldbw;
+		/* c->bw = c->oldbw; */
 		c->x = c->oldx;
 		c->y = c->oldy;
 		c->w = c->oldw;
 		c->h = c->oldh;
-		resizeclient(c, c->x, c->y, c->w, c->h);
-		arrange(c->mon);
 	}
+	resizeclient(c, c->x, c->y, c->w, c->h);
+	arrange(c->mon);
+	
 }
 
 void
@@ -1638,7 +1749,7 @@ setup(void)
 	drw = drw_create(dpy, screen, root, sw, sh);
 	if (!drw_font_create(drw, font))
 		die("no fonts could be loaded.");
-	lrpad = drw->font->h;
+	lrpad = 4;//drw->font->h;
 	bh = drw->font->h + 2;
 	updategeom();
 	/* init atoms */
@@ -1666,6 +1777,7 @@ setup(void)
 		scheme[i] = drw_scm_create(drw, colors[i], 3);
 	/* init bars */
 	updatebars();
+        clock_gettime(CLOCK_REALTIME, &current_time);
 	updatestatus();
 	/* supporting window for NetWMCheck */
 	wmcheckwin = XCreateSimpleWindow(dpy, root, 0, 0, 1, 1, 0, 0, 0);
@@ -1696,6 +1808,13 @@ seturgent(Client *c, int urg)
 	XWMHints *wmh;
 
 	c->isurgent = urg;
+	// if we are setting an urgent flag get the bar to be visible as if we started pressing the windows key.
+	// this is the non intrusive notification.
+	// See also updatewmhints
+	if (urg){
+	  Arg a = {0}; //dummy so we have an argument
+	  holdbar(&a);
+	}
 	if (!(wmh = XGetWMHints(dpy, c->win)))
 		return;
 	wmh->flags = urg ? (wmh->flags | XUrgencyHint) : (wmh->flags & ~XUrgencyHint);
@@ -1824,6 +1943,13 @@ togglebar(const Arg *arg)
 }
 
 void
+disabledoz(const Arg *arg)
+{
+  usedoz = 0;
+  updatestatus();
+}
+
+void
 togglefloating(const Arg *arg)
 {
 	if (!selmon->sel)
@@ -1910,7 +2036,9 @@ unmanage(Client *c, int destroyed)
 {
 	Monitor *m = c->mon;
 	XWindowChanges wc;
-
+	if(tadhgWM == c){
+	  tadhgWM = NULL;
+	}
 	detach(c);
 	detachstack(c);
 	if (!destroyed) {
@@ -2135,9 +2263,19 @@ updatesizehints(Client *c)
 void
 updatestatus(void)
 {
-	if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext)))
-		strcpy(stext, "dwm-"VERSION);
-	drawbar(selmon);
+  if (!gettextprop(root, XA_WM_NAME, stext, sizeof(stext))){
+	  if(usedoz){
+	    updatestatus_dozonal(stext, &current_time, &next_update);
+	  } else {
+	    updatestatus_regular(stext, &current_time, &next_update);
+	  }
+  } else {
+    // if the status is set from the XA_WM_NAME variable then the code for updating the clock should probably be avoided entirely
+    // but it is easier to just set the time for the next update very far in the future.
+    // and rely on the un-setting of that variable to call this function (which it does) and therefore update the next_update time normally.
+    next_update.tv_sec = current_time.tv_sec + 10000;
+  }
+  drawbar(selmon);
 }
 
 void
@@ -2145,8 +2283,23 @@ updatetitle(Client *c)
 {
 	if (!gettextprop(c->win, netatom[NetWMName], c->name, sizeof c->name))
 		gettextprop(c->win, XA_WM_NAME, c->name, sizeof c->name);
-	if (c->name[0] == '\0') /* hack to mark broken clients */
+	// windows with emojis in their title seem to crash dwm, for now just display broken everywhere so I can actually have a usable workflow.
+	if (c->name[0] == '\0'){ /* hack to mark broken clients */
 		strcpy(c->name, broken);
+		return;
+	}
+	// hot fix, with the pango patch dwm would crash if a window title had a colour emoji in it
+	// it is possible there is a better fix than this but as an easy patch just replace non printable characters
+	for(int idx = 0; c->name[idx] != '\0'; idx+=1){
+	  if(!(0x20 <= c->name[idx] && c->name[idx] <= 0x7E)){
+	    // outside printable ascii range, replace with ?
+	    // note that because of utf-8 the last byte of a character may be within this range
+	    // but not be intended to be interpreted as such and this logic does not catch that case
+	    // thus unicode characters may result in a arbitrary character being displayed after a sequence of ?
+	    c->name[idx] = '?';
+	  }
+	}
+	
 }
 
 void
@@ -2165,19 +2318,27 @@ void
 updatewmhints(Client *c)
 {
 	XWMHints *wmh;
-
+	int has_urgent = 0;
 	if ((wmh = XGetWMHints(dpy, c->win))) {
 		if (c == selmon->sel && wmh->flags & XUrgencyHint) {
 			wmh->flags &= ~XUrgencyHint;
 			XSetWMHints(dpy, c->win, wmh);
-		} else
+		} else {
 			c->isurgent = (wmh->flags & XUrgencyHint) ? 1 : 0;
+			has_urgent = has_urgent | c->isurgent;
+		}
 		if (wmh->flags & InputHint)
 			c->neverfocus = !wmh->input;
 		else
 			c->neverfocus = 0;
 		XFree(wmh);
 	}
+	if(has_urgent){
+	  // gives non intrusive notification when we have an urgent flag,
+	  // see also seturgent
+	  Arg a = {0};
+	  holdbar(&a);
+	}
 }
 
 void
@@ -2340,6 +2501,11 @@ bstack(Monitor *m) {
 			w = (m->ww - mx) / (MIN(n, m->nmaster) - i);
 			resize(c, m->wx + mx, m->wy, w - (2 * c->bw), mh - (2 * c->bw), 0);
 			mx += WIDTH(c);
+			if(m->nmaster == 1 && HEIGHT(c) != mh){
+			  // one main window that had an aspect ratio that allows more space
+			  mh = HEIGHT(c);
+			  ty = m->wy + mh;
+			}
 		} else {
 			h = m->wh - mh;
 			resize(c, tx, ty, tw - (2 * c->bw), h - (2 * c->bw), 0);
Common subdirectories: /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/.git and /home/tadhg/src/dwm/.git
diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/Makefile /home/tadhg/src/dwm/Makefile
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/Makefile	1969-12-31 19:00:01.000000000 -0500
+++ /home/tadhg/src/dwm/Makefile	2025-06-23 17:26:38.303124679 -0400
@@ -3,7 +3,7 @@
 
 include config.mk
 
-SRC = drw.c dwm.c util.c
+SRC = drw.c dwm.c util.c status.c
 OBJ = ${SRC:.c=.o}
 
 all: options dwm
diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/status.c /home/tadhg/src/dwm/status.c
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/status.c	1969-12-31 19:00:00.000000000 -0500
+++ /home/tadhg/src/dwm/status.c	2025-06-23 17:26:38.303124679 -0400
@@ -0,0 +1,167 @@
+#include <time.h>
+#include <string.h>
+#include <stdio.h>
+#include <stdarg.h>
+#include <math.h>
+#include "status.h"
+#include "util.h"
+
+// stolen from slstatus/util.c
+int
+pscanf(const char *path, const char *fmt, ...)
+{
+	FILE *fp;
+	va_list ap;
+	int n;
+
+	if (!(fp = fopen(path, "r"))) {
+		perror(path);
+		return -1;
+	}
+	va_start(ap, fmt);
+	n = vfscanf(fp, fmt, ap);
+	va_end(ap);
+	fclose(fp);
+
+	return (n == EOF) ? -1 : n;
+}
+
+
+#define CHARGE_NOW "/sys/class/power_supply/BAT1/charge_now"
+#define CHARGE_FULL "/sys/class/power_supply/BAT1/charge_full"
+#define CURRENT_DRAW "/sys/class/power_supply/BAT1/current_now"
+#define BAT_STATUS "/sys/class/power_supply/BAT1/status"
+
+struct battery_info {
+  double perc; // number from 0 to 1 for percentage filled
+  double hours_left; // number of hours left, negative if discharging and positive if charging
+};
+#define NAN_IF_NOT_ONE(X) if(X != 1){info.perc=NAN;info.hours_left=NAN;return info;}
+/** returns number of hours until complete,
+    negative when discharging positive when charging,
+    returns NAN on error */
+struct battery_info  get_battery_status(void){
+  static double full = 0.0;
+  double charge, current;
+  char state[13];
+  struct battery_info info;
+  NAN_IF_NOT_ONE(pscanf(BAT_STATUS, "%12[a-zA-Z ]", state));
+  if(strncmp(state, "Not charging", 10) == 0 || strcmp(state, "Full") == 0){
+    info.perc = 1.0;
+    info.hours_left = 0.0;
+    return info;
+  }
+  NAN_IF_NOT_ONE(pscanf(CURRENT_DRAW, "%lf", &current));
+  NAN_IF_NOT_ONE(pscanf(CHARGE_NOW, "%lf", &charge));
+  if(full == 0.0){
+    NAN_IF_NOT_ONE(pscanf(CHARGE_FULL, "%lf", &full));
+  }
+  info.perc = charge/full;
+  if (!strcmp(state, "Discharging")){
+    // discharging so negate charge to be negative
+    info.hours_left = -charge / current;
+  } else if (!strcmp(state, "Charging")){
+    // full - charge_now will give positive value of how much we still need to charge.
+    info.hours_left = (full - charge)/current;
+  } else {
+    // if status isn't Charging, Discharging, or Full then I have no idea what is going on.
+    info.hours_left = NAN;
+  }
+  return info;
+}
+
+// dozonal characters specified by my own custom font
+// they are put in the range for "Ideographic Telegraph Symbol For Hour X" so theoretically some fonts that implement those won't be totally wrong.
+static const char *DOZ[] ={"\u3358", // 0
+			   "\u3359", // 1
+			   "\u335a", // 2
+			   "\u335b", // 3
+			   "\u335c", // 4
+			   "\u335d", // 5
+			   "\u335e", // 6
+			   "\u335f", // 7
+			   "\u3360", // 8
+			   "\u3361", // 9
+			   "\u3362", //10
+			   "\u3363", //11
+			   // 12 shouldn't be used in typical usage but full battery and leap seconds can hit this case.
+			   // although for leap seconds I think it would end up being the 3rd digit that overflows given
+			   // how the code below is structured.
+			   "\u3364"};
+
+// used for seasons in the date system, this ordering seems the most natural to me for the quarters of the year roughly
+// matching seasons but if I wanted to use this system to save files I'd want to figure out symbols that have strictly
+// increasing unicode values for sorting.
+static const char *SUITS[] = {
+  "\u2666", // diamond
+  "\u2665", // heart
+  "\u2663", // club
+  "\u2660"  // spade
+};
+/**
+   updates stext to show: (battery percentage, time until battery full/empty, date, time)
+   where the date uses my silly 4*13*7 + 1 system and the rest uses dozonal.
+   The battery "percentage" is really just twelves, the percentage symbol is kind of misleading but since the battery fraction
+   is the only thing that uses the percentage symbol it makes it clearer what it represents.
+ */
+void updatestatus_dozonal(char* stext, struct timespec *current_time, struct timespec *next_update){
+  struct tm *val = localtime(&current_time->tv_sec);
+  int digAB = val->tm_hour*6 + val->tm_min/10;
+  int secs_left = (val->tm_min%10)*60 + val->tm_sec; // note due to leap seconds tm_sec can go up to 61
+  int digC = secs_left/50;
+  // ((seconds left%50 to nsec) + nanoseconds) / (50s to nsec) = fraction of dig3. multiplying by 144 gives it in terms of dig5.
+  long digDE = (((long)((secs_left%50) * 1e9) + current_time->tv_nsec) * 144 / 50e9);
+  
+  int season = val->tm_yday/91;
+  if(season>3){season = 3;} // when yday is 364 or 365 we still want season to be the 4th one (0 indexed is 3)
+  int day_of_season = val->tm_yday - season*91;
+  char week = 'a'+(day_of_season/7); // will go to n0 for last day of year and n1 for leap year.
+  char day = '0'+val->tm_yday%7;
+
+  struct battery_info info = get_battery_status();
+
+  char charge_sign = info.hours_left == 0 ? '/' : info.hours_left > 0 ? '+' : '-';
+  int charge_digA = isnan(info.perc) ? 0 : (int)(info.perc*12.0);
+  int remaining_A, remaining_B, remaining_C;
+  if(isnan(info.hours_left)){
+      charge_sign = '?';
+      remaining_A = 0;
+      remaining_B = 0;
+      remaining_C = 0;
+  } else if(fabs(info.hours_left) >= 24.0){
+    remaining_A = 12;
+    remaining_B = 12;
+    remaining_C = 12;
+  } else{
+    int left = (int)(fabs(info.hours_left) * 72.0);
+    remaining_A = left/144;
+    remaining_B = (left/12)%12;
+    remaining_C = left%12;
+  }
+  
+  sprintf(stext, "%s%% %c.%s%s%s %d%s%c%c.%s%s%s%s%s", DOZ[charge_digA], charge_sign, DOZ[remaining_A], DOZ[remaining_B], DOZ[remaining_C], val->tm_year+1900, SUITS[season], week, day, DOZ[digAB/12], DOZ[digAB%12], DOZ[digC], DOZ[digDE/12], DOZ[digDE%12]);
+
+  // and calculate the time that will next result in an update, next dig45
+  long ns_next = (digDE+1)*50e9/144 - (secs_left%50) * 1e9;
+  next_update->tv_sec = (ns_next < 1e9) ? current_time->tv_sec : current_time->tv_sec+1;
+  next_update->tv_nsec= (ns_next < 1e9) ? ns_next : ns_next-1e9;
+}
+/** updates stext to display same info as dozonal function above but using more typical numbering */
+void updatestatus_regular(char* stext, struct timespec *current_time, struct timespec *next_update){
+  struct tm *val = localtime(&current_time->tv_sec);
+  struct battery_info info = get_battery_status();
+  int perc = (int)(info.perc*100.0);
+  int hours = (int)(info.hours_left);
+  int mins = (int)((info.hours_left - hours)*60);
+
+  if(isnan(info.hours_left)){
+    perc = -1;
+    hours = 888;
+    mins = 0;
+  } else if(mins < 0){
+    mins = -mins; // allow hours to display with negative but get minutes to be positive always.
+  }
+  sprintf(stext, " %2d%% %+dh %dm, %4d-%02d-%02d %2d:%02d:%02d",perc,hours,mins, val->tm_year+1900, val->tm_mon+1, val->tm_mday, val->tm_hour, val->tm_min, val->tm_sec);
+  next_update->tv_sec = current_time->tv_sec + 1;
+  next_update->tv_nsec = 0;
+}
diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/status.h /home/tadhg/src/dwm/status.h
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/status.h	1969-12-31 19:00:00.000000000 -0500
+++ /home/tadhg/src/dwm/status.h	2025-06-23 17:26:38.303124679 -0400
@@ -0,0 +1,5 @@
+
+void updatestatus_dozonal(char* stext, struct timespec *current_time, struct timespec *next_update);
+
+void updatestatus_regular(char* stext, struct timespec *current_time, struct timespec *next_update);
+
diff -up -N /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/TAGS /home/tadhg/src/dwm/TAGS
--- /gnu/store/3salscyfh8v3a3s5ns5a5fhnr84hzgw8-dwm-6.4-checkout/TAGS	1969-12-31 19:00:00.000000000 -0500
+++ /home/tadhg/src/dwm/TAGS	2025-09-10 15:06:01.701560779 -0400
@@ -0,0 +1,386 @@
+
+drw.c,413
+drw_create(14,260
+drw_resize(31,676
+drw_free(44,943
+xfont_create(56,1190
+xfont_free(87,1943
+drw_font_create(97,2061
+drw_font_free(110,2231
+drw_clr_create(118,2302
+drw_scm_create(132,2770
+drw_setscheme(147,3108
+drw_rect(154,3183
+drw_text(166,3571
+drw_map(232,5282
+drw_font_getwidth(242,5492
+drw_font_getwidth_clamp(250,5670
+drw_font_getexts(259,5896
+drw_cur_create(279,6407
+drw_cur_free(292,6593
+
+dwm.c,7881
+#define BUTTONMASK 51,1602
+#define CLEANMASK(52,1670
+#define INTERSECT(53,1806
+#define ISVISIBLE(55,1987
+#define LENGTH(56,2065
+#define MOUSEMASK 57,2122
+#define WIDTH(58,2185
+#define HEIGHT(59,2240
+#define TAGMASK 60,2295
+#define TEXTW(61,2353
+#define TEXTWM(62,2430
+enum { CurNormal,65,2519
+enum { CurNormal, CurResize,65,2519
+enum { CurNormal, CurResize, CurMove,65,2519
+enum { CurNormal, CurResize, CurMove, CurLast 65,2519
+enum { SchemeNorm,66,2581
+enum { SchemeNorm, SchemeSel,66,2581
+enum { SchemeNorm, SchemeSel, SchemeFade 66,2581
+enum { NetSupported,67,2645
+enum { NetSupported, NetWMName,67,2645
+enum { NetSupported, NetWMName, NetWMState,67,2645
+enum { NetSupported, NetWMName, NetWMState, NetWMCheck,67,2645
+       NetWMFullscreen,68,2701
+       NetWMFullscreen, NetActiveWindow,68,2701
+       NetWMFullscreen, NetActiveWindow, NetWMWindowType,68,2701
+       NetWMWindowTypeDialog,69,2759
+       NetWMWindowTypeDialog, NetClientList,69,2759
+       NetWMWindowTypeDialog, NetClientList, NetLast 69,2759
+enum { WMProtocols,70,2832
+enum { WMProtocols, WMDelete,70,2832
+enum { WMProtocols, WMDelete, WMState,70,2832
+enum { WMProtocols, WMDelete, WMState, WMTakeFocus,70,2832
+enum { WMProtocols, WMDelete, WMState, WMTakeFocus, WMLast 70,2832
+enum { ClkTagBar,71,2914
+enum { ClkTagBar, ClkLtSymbol,71,2914
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText,71,2914
+enum { ClkTagBar, ClkLtSymbol, ClkStatusText, ClkWinTitle,71,2914
+       ClkClientWin,72,2973
+       ClkClientWin, ClkRootWin,72,2973
+       ClkClientWin, ClkRootWin, ClkLast 72,2973
+struct timespec current_time;74,3031
+struct timespec next_update;75,3061
+int usedoz 76,3090
+	int i;79,3123
+	unsigned int ui;80,3131
+	float f;81,3149
+	const void *v;v82,3159
+} Arg;83,3175
+	unsigned int click;86,3200
+	unsigned int mask;87,3221
+	unsigned int button;88,3241
+	void (*func)func89,3263
+	const Arg arg;90,3294
+} Button;91,3310
+typedef struct Monitor Monitor;93,3321
+typedef struct Client Client;94,3353
+struct Client 95,3383
+	char name[name96,3399
+	float mina,97,3416
+	float mina, maxa;97,3416
+	int x,98,3435
+	int x, y,98,3435
+	int x, y, w,98,3435
+	int x, y, w, h;98,3435
+	int oldx,99,3452
+	int oldx, oldy,99,3452
+	int oldx, oldy, oldw,99,3452
+	int oldx, oldy, oldw, oldh;99,3452
+	int basew,100,3481
+	int basew, baseh,100,3481
+	int basew, baseh, incw,100,3481
+	int basew, baseh, incw, inch,100,3481
+	int basew, baseh, incw, inch, maxw,100,3481
+	int basew, baseh, incw, inch, maxw, maxh,100,3481
+	int basew, baseh, incw, inch, maxw, maxh, minw,100,3481
+	int basew, baseh, incw, inch, maxw, maxh, minw, minh,100,3481
+	int basew, baseh, incw, inch, maxw, maxh, minw, minh, hintsvalid;100,3481
+	int bw,101,3548
+	int bw, oldbw;101,3548
+	unsigned int tags;102,3564
+	int isfixed,103,3584
+	int isfixed, isfloating,103,3584
+	int isfixed, isfloating, isurgent,103,3584
+	int isfixed, isfloating, isurgent, neverfocus,103,3584
+	int isfixed, isfloating, isurgent, neverfocus, oldstate,103,3584
+	int isfixed, isfloating, isurgent, neverfocus, oldstate, isfullscreen;103,3584
+	Client *next;next104,3656
+	Client *snext;snext105,3671
+	Monitor *mon;mon106,3687
+	Window win;107,3702
+	unsigned int mod;111,3736
+	KeySym keysym;112,3755
+	void (*func)func113,3771
+	const Arg arg;114,3799
+} Key;115,3815
+	const char *symbol;symbol118,3840
+	void (*arrange)arrange119,3861
+} Layout;120,3890
+typedef struct Pertag Pertag;122,3901
+struct Monitor 123,3931
+	char ltsymbol[ltsymbol124,3948
+	float mfact;125,3968
+	int nmaster;126,3982
+	int num;127,3996
+	int by;128,4006
+	int mx,129,4048
+	int mx, my,129,4048
+	int mx, my, mw,129,4048
+	int mx, my, mw, mh;129,4048
+	int wx,130,4089
+	int wx, wy,130,4089
+	int wx, wy, ww,130,4089
+	int wx, wy, ww, wh;130,4089
+	unsigned int seltags;131,4131
+	unsigned int sellt;132,4154
+	unsigned int tagset[tagset133,4175
+	int showbar;134,4200
+	int topbar;135,4214
+	Client *clients;clients136,4227
+	Client *sel;sel137,4245
+	Client *stack;stack138,4259
+	Monitor *next;next139,4275
+	Window barwin;140,4291
+	const Layout *lt[lt141,4307
+	Pertag *pertag;pertag142,4329
+	const char *instance;instance147,4387
+	const char *title;title148,4410
+	unsigned int tags;149,4430
+	int isfloating;150,4450
+	int monitor;151,4467
+} Rule;152,4481
+	const char **cmd;cmd155,4507
+	unsigned int tags;156,4526
+} Autostarttag;157,4546
+static const char broken[broken263,8533
+static char stext[stext264,8572
+static int screen;265,8596
+static int sw,266,8615
+static int sw, sh;266,8615
+static int bh;267,8690
+static int lrpad;268,8736
+static unsigned int numlockmask 270,8862
+static Atom wmatom[wmatom289,9441
+static Atom wmatom[WMLast], netatom[netatom289,9441
+static int running 290,9487
+static Cur *cursor[cursor291,9511
+static Clr **scheme;scheme292,9540
+static Display *dpy;dpy293,9561
+static Drw *drw;drw294,9582
+static Monitor *mons,mons295,9599
+static Monitor *mons, *selmon;selmon295,9599
+static Window root,296,9630
+static Window root, wmcheckwin;296,9630
+static unsigned int autostarttags 297,9662
+static int autostartcomplete 298,9701
+static int autostartcmdscomplete 299,9735
+struct Pertag 304,9861
+	unsigned int curtag,305,9877
+	unsigned int curtag, prevtag;305,9877
+	int nmasters[nmasters306,9939
+	float mfacts[mfacts307,10011
+	unsigned int sellts[sellts308,10065
+	const Layout *ltidxs[ltidxs309,10128
+struct NumTags 313,10291
+struct NumTags { char limitexceeded[limitexceeded313,10291
+holdbar(317,10396
+keyrelease(327,10592
+updateholdbarpos(354,11223
+applyrules(367,11438
+applysizehints(403,12290
+arrange(471,13938
+arrangemon(485,14154
+attach(493,14317
+attachstack(500,14395
+buttonpress(507,14475
+checkotherwm(555,15843
+cleanup(566,16122
+cleanupmon(594,16751
+clientmessage(610,17005
+configure(629,17558
+configurenotify(648,17908
+configurerequest(676,18538
+createmon(728,19929
+destroynotify(757,20596
+detach(767,20745
+detachstack(776,20870
+dirtomon(790,21118
+drawbar(805,21358
+drawbars(860,23056
+enternotify(869,23141
+expose(888,23522
+focus(898,23662
+focusin(924,24313
+focusmon(933,24457
+focusstack(947,24636
+getatomprop(973,25149
+getrootptr(989,25441
+getstate(999,25594
+gettextprop(1017,25931
+grabbuttons(1040,26475
+grabkeys(1061,27122
+incnmaster(1079,27578
+isuniquegeom(1087,27759
+keypress(1098,28049
+int are_any_clients_running(1113,28369
+killclient(1122,28507
+manage(1144,29147
+mappingnotify(1209,30902
+maprequest(1219,31054
+monocle(1231,31300
+motionnotify(1246,31655
+movemouse(1263,31937
+nexttiled(1323,33571
+pop(1330,33674
+propertynotify(1339,33752
+quit(1376,34588
+recttomon(1382,34638
+resize(1396,34848
+resizeclient(1403,34999
+resizemouse(1418,35365
+restack(1475,37047
+update_time(1520,38761
+run(1560,40342
+scan(1575,40664
+sendmon(1602,41376
+setclientstate(1618,41632
+sendevent(1627,41826
+setfocus(1652,42349
+setfullscreen(1664,42632
+setlayout(1695,43595
+setmfact(1710,44087
+setup(1724,44376
+seturgent(1795,47301
+showhide(1815,47807
+sigchld(1833,48207
+spawn(1841,48361
+tag(1853,48578
+autostarttagsspawner(1863,48727
+applyautostarttags(1880,49024
+tagmon(1890,49138
+tile(1898,49256
+togglebar(1926,49962
+disabledoz(1935,50186
+togglefloating(1942,50255
+togglefullscr(1956,50625
+toggletag(1963,50743
+toggleview(1978,50968
+unfocus(2011,51991
+unmanage(2024,52281
+unmapnotify(2050,52867
+updatebars(2064,53071
+updatebarpos(2086,53682
+updateclientlist(2099,53893
+updategeom(2113,54197
+updatenumlockmask(2191,55989
+updatesizehints(2207,56351
+updatestatus(2251,57523
+updatetitle(2269,58219
+updatewindowtype(2293,59309
+updatewmhints(2305,59585
+view(2332,60183
+wintoclient(2367,61201
+wintomon(2380,61383
+xerror(2400,61849
+xerrordummy(2418,62675
+xerrorstart(2426,62824
+zoom(2433,62945
+main(2445,63163
+bstack(2469,63701
+bstackhoriz(2506,64622
+
+status.c,432
+pscanf(11,169
+#define CHARGE_NOW 30,423
+#define CHARGE_FULL 31,484
+#define CURRENT_DRAW 32,547
+#define BAT_STATUS 33,611
+struct battery_info 35,669
+  double perc;36,691
+  double hours_left;37,750
+#define NAN_IF_NOT_ONE(39,848
+struct battery_info  get_battery_status(43,1059
+static const char *DOZ[DOZ75,2289
+static const char *SUITS[SUITS95,3104
+void updatestatus_dozonal(107,3618
+void updatestatus_regular(150,5776
+
+transient.c,16
+int main(8,127
+
+util.c,28
+die(10,162
+ecalloc(29,405
+
+config.def.h,1603
+static const unsigned int borderpx 4,103
+static const unsigned int snap 5,181
+static const int showbar 7,376
+static const int topbar 8,445
+static const char font[font9,518
+static const char dmenufont[dmenufont10,572
+static const char col_gray1[col_gray111,631
+static const char col_gray2[col_gray212,680
+static const char col_gray3[col_gray313,729
+static const char col_gray4[col_gray414,778
+static const char col_cyan[col_cyan15,827
+static const char *colors[colors16,876
+static const char *tags[tags27,1454
+static const Rule rules[rules36,2289
+static const float mfact 47,2656
+static const int nmaster 48,2739
+static const int resizehints 49,2815
+static const int lockfullscreen 50,2903
+static const float MIN_ASPECT_RATIO_TO_TILE_HORIZONTALLY 53,3009
+static const float SHRINK_FACTOR_FOR_FULLSCREEN 55,3141
+void myresize(58,3394
+void mytile(68,3894
+static const Layout layouts[layouts114,5880
+#define MODKEY 124,6186
+#define TAGKEYS(125,6210
+#define HOLDKEY 130,6559
+#define HYPERKEY 131,6635
+#define SHCMD(134,6728
+static const char *dmenucmd[dmenucmd138,6819
+static const char *termcmd[termcmd139,6968
+static const char *chatclientcmd[chatclientcmd140,7023
+static const char *discord[discord141,7078
+static const char *browsercmd[browsercmd144,7288
+static const char *emailclientcmd[emailclientcmd145,7339
+static const char *emacscmd[emacscmd146,7396
+static const char *insertemoji[insertemoji147,7497
+Autostarttag autostarttaglist[autostarttaglist149,7557
+static const Key keys[keys165,8293
+static const Button buttons[buttons265,16145
+
+drw.h,500
+	Cursor cursor;4,76
+} Cur;5,92
+typedef struct Fnt 7,100
+	Display *dpy;dpy8,121
+	unsigned int h;9,136
+	PangoLayout *layout;layout10,153
+} Fnt;11,175
+enum { ColFg,13,183
+enum { ColFg, ColBg,13,183
+enum { ColFg, ColBg, ColBorder 13,183
+typedef XftColor Clr;14,240
+	unsigned int w,17,280
+	unsigned int w, h;17,280
+	Display *dpy;dpy18,300
+	int screen;19,315
+	Window root;20,328
+	Drawable drawable;21,342
+	GC gc;22,362
+	Clr *scheme;scheme23,370
+	Fnt *font;font24,384
+} Drw;25,396
+
+util.h,60
+#define MAX(4,71
+#define MIN(7,146
+#define BETWEEN(9,209
+
+status.h,0
