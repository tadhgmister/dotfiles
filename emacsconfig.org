This file serves several purposes:
- it documents my workflows and configurations regarding emacs for my own reference
- the configuration elisp code is compiled to an init.el file that is loaded by emacs
- it is used as an org agenda file so TASK/TODO headlines can be used with org agenda

* TASK [#C] [12/14] Tech gripes
:PROPERTIES:
:CUSTOM_ID: TechGripes
:ID:       TechGripes
:END:

list of small gripes that I could improve on, mostly related to emacs but other guix configuration is fair game

working on this task means refiling these to proper places, not necessarily working on these items.

- [X] side scrolling / line wrapping behaviour
- [X] dwm make tags narrower and unconditionally display all of them
  (will require pulling out one of the patches I use to only show the
  active ones)
- [X] [[*coloured parenthases][setup coloured parens]]
- [X] set EMAIL variable in [[./home-config.scm]] to contain my email 
- [ ] quick way to view buffers filename, ideally tooltip on 'buffername' in modeline
- [ ] setup org file src insert to offer sub-modes and open narrowed buffer instead of edit special
- [X] get org blocked logic to not consider checkbox items
- [X] add org capture template for new task to inbox
- [X] emacs smooth scrolling
- [X] get playtimer to show dunst alert
- [X] guix home, better handling of nix profiles so that the profile can be rebuilt when channels are changed
- [X] org agenda sort categories
- [X] dwm hug emoji binding (or possibly whole emoji selection with dmenu)
- [X] configure xdg in home-config to use emacsclient instead of emacs when opening files associated with emacs

* guix / non emacs dotfiles
these are things that are related to guix or dwm or other technical aspects of my personal setup
** DONE get dwm to switch focus when window raises in same space
When emacs tries to raise a frame into focus it sends an urgency flag
to dwm which is invaluable when the frame is in a different space, but
when it is in the same space it is annoying to open the top bar to
indicate there is activity in the selected space.

Instead it would be nice to identify specifically the window raising
event (not necessarily the urgency bell) to switch focus to that frame
instead of setting urgency flag.

see [[~/src/dwm/dwm.c::window was raised for focus][clientmessage in dwm.c]] for fix.
** TASK change power button behaviour
currently if the system suspends itself the keyboard and trackpad
disable themselves, so you can only wake the system back up by
pressing the power button, which is then processed as an input and
triggers hibernation. This is extremely frustrating. Instead I'd like
it so the power button does nothing on the kernel side but detect it
in dwm and have different modifiers do different things
(power/hibernate/suspend)

** TASK look into adding guix manifests/profiles to home config
for things like language servers to use in emacs it will be highly
desirable to not require installing certain packages but instead have
a `guix shell` profile with the relevant software ready to go and
referenced by emacs commands. This could similarly setup python
environments that aren't installed by default but are available when
needed.

** TASK [#C] set EMAIL variable
:PROPERTIES:
:Effort:   1min
:END:

** TASK [0/3] extract nix logic into home service
- [ ] nix channels, packages possibly as children of each channel
- [ ] list of nix packages (with some way to specify options for "allow non free stuff" that would be allowable to push to guix)
- [ ] way to split out the nix pull behaviour? 

* Notes about this file
#+PROPERTY: header-args :tangle yes
all code blocks will be output with tangle unless explicitly labeled ~:tangle no~.
** todo tags
#+TODO: TASK(t) SOON(s) TODO(n) REFILE(r) | DOC DONE(~) DEFERRED(d)
See [[*keywords and todo behaviour][keywords and todo behaviour]] for
meaning of most of these tags, the ones added to this file are:
- REFILE means the location of the code in that heading is probably in
  the wrong spot and should be moved to a more appropriate section.
- DOC means the human documentation could be updated, I.E. links to
  relevant sections. It does *not* denote sections that only contain
  documentation.
** window vs frame terminology
The use of the terms =window= and =frame= in this document match emacs
terminology. Quote from [[info:emacs#Screen][emacs#Screen]]:

#+begin_quote
The main area of the frame, below the tool bar (if one exists) and
above the echo area, is called “the window”.  Henceforth in this manual,
we will use the word “window” in this sense.  Graphical display systems
commonly use the word “window” with a different meaning; but, as stated
above, we refer to those graphical windows as “frames”.
#+end_quote

** markup used in this file
emacs variables or functions use the "code" markup like
~display-buffer~, generally any term surrounded by tilda (=~=) should
hit a emacs help entry by doing =C-h v= or =C-h f= with your cursor on
the variable name.

Key codes and other partial code or symbols will use the "verbatim"
marker surrounded by equal signs as seen above.

** lexical bindings
I want to use lexical bindings because they seem like the sane option
but I then get errors that variables are unsused and idk how to fix that.
#+begin_src emacs-lisp
  ;;; ...  -*- lexical-binding: t -*-
#+end_src

* misc functions :func:
** set-alist
the built in function [[help:add-to-list][add-to-list]] inserts at the beginning of a list
if the item is not already present, this is sufficient to override an
item in an alist however it would be preferable to override the entry
of an alist if present as reloading the init file multiple times would
bloat config stuff otherwise.
#+begin_src emacs-lisp
  (defun equal-car (a b)
    "returns (equal (car a) (car b)). Used for adding to alists"
    (equal (car a) (car b)))

  (defun add-to-alist (list-var key value)
    "like `add-to-list' but overrides existing entry if value is already present."
    (add-to-list list-var (cons key value) nil #'equal-car))
#+end_src


* keybindings
** Using hyper modifier
in [[./home-config.scm::(Xmodmap][xinit profile setup]] the right control key is rebound to the hyper
modifier, then in emacs we swap the control and hyper modifiers.
#+begin_src emacs-lisp
  (setopt x-hyper-keysym 'ctrl)
  (setopt x-ctrl-keysym 'hyper)
#+end_src

This means that in emacs the left control key produces the =H-= prefix
giving us full control over which bindings we put on the normally used
control key while existing emacs bindings are still accessible with
the left control key.

** Custom functions to bind to keys
*** new frame
  
By default the command to open a new frame in emacs shows the same
buffer as the current one which is a very reasonable default but not
as useful as I would like.

Some helper functions are here to support [[*my/new-frame]] as the main
keybinding to open a new frae, see its description for what it does.

**** my/try-switch-to-prev-buffer                                      :func:
~switch-to-prev-buffer~ can throw errors in cases like if the minibuffer is selected so write a little wrapper to suppress any errors.
#+begin_src emacs-lisp
  (defun my/try-switch-to-prev-buffer (&optional window bury-or-kill)
  "tries to call `switch-to-prev-buffer' but catches errors if it
  can't switch and returns nil in those cases"
  (condition-case nil
      (switch-to-prev-buffer window bury-or-kill)
    (error nil)))
#+end_src
**** my/pop-buffer-into-frame :func:
#+NAME: doc/pop-buffer-into-frame
This function will switch the current selected window to show the previous buffer, makes a new frame, and has the new frame display the buffer that was being displayed before switching or if it couldn't switch to a previous buffer it switches to the buffer returned by `initial-buffer-choice'.

Note that the way this function uses ~initial-buffer-choice~ depends
on it being a function and not any of the other formats it is allowed
to be, see [[*Initial Buffer]].

#+begin_src emacs-lisp
  (defun my/pop-buffer-into-frame ()
    "see emacsconfig.org:my/pop-buffer-into-frame"
    (interactive)
    (let* ((buf (current-buffer))
  	(buffer-for-new-frame (if (my/try-switch-to-prev-buffer)
  				  buf (funcall initial-buffer-choice)))
  	(frame (make-frame)))
      (select-frame-set-input-focus frame)
      (switch-to-buffer buffer-for-new-frame nil t)))
#+end_src
**** my/new-frame :func:
Since the main usage of opening a new frame is to view 2 buffers in
split screen there are 2 expected cases:
- I just opened a buffer over the previous one that I want to view in
  parallel with the previous one
- I just opened a buffer that split the frame into multiple windows
  and want to keep the newly opened window around

The function [[*my/pop-buffer-into-frame]] performs the first task, so
this function checks which case is relevant and either calls that
helper or does the copying window state into new frame logic for other
case.


#+begin_src emacs-lisp
    (defun my/new-frame ()
      "
  If the current frame has more than one window pop the selected
  one into a new frame, otherwise call `my/pop-buffer-into-frame'"
      (interactive)
      (if (cdr (window-list)) ;; if window list has more than one entry
          (let* ((cur-win (selected-window))
    	     (win-state (window-state-get cur-win))
    	     (frame (make-frame)))
    	(delete-window cur-win)
    	(select-frame-set-input-focus frame)
    	(window-state-put win-state (selected-window)))
        (my/pop-buffer-into-frame)))
#+end_src
*** REFILE org capture + org agenda
idk why this functionality doesn't exist already, I'd like to bind a
key to org-capture but also want a quick way to view the org agenda -
specifically the 2 views I actually use (see [[agenda view][here]]).

So I will write my own version of [[help:org-capture-select-template][org-capture-select-template]] to
select a template passing some extra options for agenda views I want
easily accessible, then forwarding the info to ~org-agenda~ or ~org-capture~ respectively.

Note that this completely bypasses contextual logic, using this does
*not* respect [[help:org-capture-templates-contexts][org-capture-templates-contexts]] since I don't use that
myself and also skips a call to ~org-capture-upgrade-templates~ which
applies backward compatibility checks which I shouldn't need as I am
using recent template specifications.

#+begin_src emacs-lisp
  (use-package org-capture
    :defines org-capture-templates)
  (defun my/org-capture-or-agenda-wrapper ()
    "see description in emacsconfig.org"
    (interactive)
    ;; note we are relying on org-capture seeing this variable name to prevent it from giving its own prompt
    (let ((org-capture-entry
  	 (org-mks org-capture-templates
  		  "Select a capture template or agenda view\n========================="
  		  "Template or view key: "
  		  ;; note that 't' is a key defined internally
  		  ;; by the agenda, n is rebindable and could
  		  ;; make an alias for 't' but would probably
  		  ;; want to think about the best way to
  		  ;; actually do that
  		  '(("t" "Global task list")
  		    ("n" "Agenda and TODO list")
  		    ("q" "Abort")))))
      (cond
       ((equal org-capture-entry "q")
        (user-error "Abort"))
       ((stringp org-capture-entry)
        (org-agenda nil org-capture-entry))
       (t
        (org-capture)))))
#+end_src
** Key Bindings
This is the table of commands I bind globally, note that bindings for
mode specific tasks may be present elsewhere in this document.

The columns are as follows:
- Key, the key as interpreted by emacs ~kbd~ function.
- Command, the emacs function to run on the keystroke. Note that typos
  in the function name throw errors when processing the init file not
  at compile time.
- Orig, denotes the default binding emacs uses for the same
  function, note that if the function starts with =my/= this denotes
  the binding for a built in command that my function mimics.
- Type, denotes why I have the binding, one of:
  - CUA - for consistency with other apps, not necessarily defined in
    [[https://en.wikipedia.org/wiki/IBM_Common_User_Access][CUA standards]] but _Common User Access_ is the right meaning to me.
  - Emacs - binding is similar to default binding for functionality I
    use enough to want a quicker access to it.
  - Code - used for programming and maps to functionality common across languages
  - Mine - runs a function I wrote myself and doesn't have a clear equivelent
- Description, a description of the command, for CUA this is the label
  usually used in menu bars of other apps.
  
#+NAME: keybindings
| Key           | Command                          | Orig        | Type  | Description        |
|---------------+----------------------------------+-------------+-------+--------------------|
| H-<backspace> | kill-buffer                      | C-x k       | Mine  | close buffer       |
| H-g           | keyboard-quit                    | C-g         | Emacs | Abort              |
| H-x           | kill-region                      | C-w         | CUA   | Cut                |
| H-c           | kill-ring-save                   | M-w         | CUA   | Copy               |
| H-v           | yank                             | C-y         | CUA   | Paste              |
| H-s           | save-buffer                      | C-x C-s     | CUA   | Save               |
| H-a           | mark-whole-buffer                | C-x h       | CUA   | Select All         |
| H-z           | undo                             | C-x u       | CUA   | Undo               |
| H-Z           | undo-redo                        | C-M-_       | CUA   | Redo               |
| H-f           | isearch-forward                  | C-s         | CUA   | Find               |
| H-o           | find-file                        | C-x C-f     | CUA   | Open File          |
| H-F           | find-file                        | C-x C-f     |       | H-o with one hand  |
| H-n           | my/new-frame                     | C-x 5 2     | CUA   | New Window         |
| H-/           | comment-or-uncomment-region      |             | Code  | (un)comment        |
| H-<left>      | previous-buffer                  | C-x <left>  | Emacs | Go Back (buffer)   |
| H-<right>     | next-buffer                      | C-x <right> | Emacs | next buffer        |
| H-`           | my/org-capture-or-agenda-wrapper |             | Mine  | org agenda/capture |

#+BEGIN_SRC emacs-lisp :var table=keybindings
  (dolist (row table)
    (let ((key (car row))
          (cmd (intern (cadr row))))
      (unless (fboundp cmd)
          (error "Function '%s' is not defined (used in keybinding for '%s')" cmd key))
      (global-set-key (kbd key) cmd)))
#+END_SRC
*** DONE get H-S to work
wtf? emacs automatically maps H-S-z to just H-z so I don't have a redo
command... this is most frustrating. need to figure out why it is
doing that and how to disable it.

Had to specify as capital letters instead of adding shift prefix, I am
totally unclear how it can create a binding for H-S-z seperate from
H-Z but ok fine.
** DEFERRED [0/1] mode specific bindings
- [ ] rebind C-c & in org mode ~(org-mark-ring-goto)~ to M-, may have an
  equivelent to go forward but probably not as it is to navigate back
  from a hyperlink

** Default emacs bindings that I use often
*** Programming
- M-. goes to the definition of the symbol under the cursor, like alt+click in vscode
- M-, goes back to point you were at before doing M-.
- M-<tab> complete-symbol
*** Org
- M-<return> adds a new item, if cursor is in a list it makes a new bullet point otherwise a new heading
- M-S-<return> same as M-<return> but labels it as a todo or inserts a checkbox

*** TASK C-g since H-g doesn't abort minibuffers
there is conditional binding on C-g when in the middle of running a
command in the minibuffer, this also means if you navigate away from
that minibuffer C-g doesn't cancel it and if it is on a frame outside
your view this can be extremely annoying so letting H-g abort
minibuffer globally would be very useful.

*** TASK C-s since H-f doesn't repeat search
C-s has conditional binding when performing a search to look for the
next occurance of text, should do the same with H-f and maybe add some
behaviour where it tries to search for text from the clipboard by
default

* Initial Buffer
The [[help:initial-buffer-choice][initial buffer choice]] is used when a frame is opened with [[info:emacs#Invoking
 emacsclient][emacsclient]] shell command without specifying a file to visit.  It can
be given different forms but I will use a function to refresh the org
agenda and then return it so new frames will be opened to the org
agenda.
** my/get-org-agenda                                                   :func:
#+begin_src emacs-lisp
  (require 'org-agenda)
  (defun my/get-org-agenda ()
    "generates the org agenda if it doesn't yet exist, refreshes it if
  it does and returns the buffer for the agenda without modifying
  any window configuration"
    (if-let ((buf (get-buffer org-agenda-buffer-name)))
        ;; if the org agenda buffer exists reload it and return as is
        (with-current-buffer buf
  	(org-agenda-redo t) ;;true for `all' parameter, not clear on what it changes
  	buf)
      ;; otherwise run org-agenda which sets the view to the hardcoded value here
      (save-window-excursion
        (org-agenda nil "n")
        (get-buffer org-agenda-buffer-name))))

#+end_src

*** TASK make the initially selected org view less hard coded
in ~my/get-org-agenda~ the "n" is hard coded as the initial org agenda
view, should probably make it less buried.
** initial buffer choice
use the function to load the org agenda as the initial buffer choice.

Note: [[*my/pop-buffer-into-frame]] depends on ~initial-buffer-choice~
being a function and not any other supported form as the handling of
its options is not reusable in the emacs source.

#+begin_src emacs-lisp
  (setopt initial-buffer-choice #'my/get-org-agenda)
#+end_src
** REFILE org agenda window setup
as we mainly make use of ~my/get-org-agenda~ to load the org agenda, and it reverts edits to the window layout tell org to not bother trying to edit window layout if it is called from elsewhere.
#+begin_src emacs-lisp
(setopt org-agenda-window-setup 'current-window)
#+end_src

* Graphics / display
** DOC Theme
this is a dark theme that morgan recommended as being well designed to have very high contrast. I suspect this is true and suspect the =t= is to enable dark mode but have no idea.
#+begin_src emacs-lisp
(load-theme 'modus-vivendi t)
#+end_src
** use modeline for selection not dialogue boxes
I may want to reconsider this at some point but certainly for
[[my/close-frame][my/close-frame]] the menu options are highly confusing (quit=cancel
closing window) and the dialogue blocks viewing the buffer.

#+begin_src emacs-lisp
  (setopt use-dialog-box nil)
#+end_src

** DONE make modeline more visible
:LOGBOOK:
CLOCK: [2025-08-06 Wed 14:05]--[2025-08-06 Wed 14:46] =>  0:41
:END:
When multiple windows are open on a frame it is very hard to easily
notice, will set the box to be red to make it stand out more.
#+begin_src emacs-lisp
  (let ((box-style '(:line-width (1 . 1) :color "#ff0000")))
    (set-face-attribute 'mode-line-inactive
  		      nil :box box-style)
    (set-face-attribute 'mode-line-active
  		      nil :box box-style))
#+end_src
** TASK coloured parenthases

** TASK scrolling and line wrapping
- get smooth scrolling, probably external package?
- set default to visual line wrap so it stops scrolling horizontally
  without giving me a consistent way to scroll back
  

* Backups and Auto-saves
** backups
see [[info:emacs#Backup][emacs#Backup]], it mentions that ~vc-make-backup-files~ defaults to
~nil~ to not make backups of files under version control but this
applies based on files being checked in to the version control and
thus adding new files to a git repo has backups you need to avoid and
then delete and once it is checked into version control the backups
stop getting made.

I override the predicate to disable backups if there is a git root,
meaning untracked files in a git repo will not have backups made for
them.

#+begin_src emacs-lisp
  (require 'vc-git)
  (setopt backup-enable-predicate
      (lambda (filename)
        (and (normal-backup-enable-predicate filename)
  	     (not (vc-git-root filename)))))
#+end_src
** autosaves
the default logic to make autosaves and record lists of autosaved
files is great, the default user experience of making use of those
files is horrible. Instead I want to just load all autosave files we
can find on startup.
*** REFILE load cl-lib to allow patching prompt function
this is needed for ~cl-letf~ function used by ~my/try-recover-file~,
should probably set it to auto load or something as we only actually
need it if there are autosave lists to process which if all goes well
won't happen often.
#+begin_src emacs-lisp
  (require 'cl-lib)
#+end_src
*** my/try-recover-file                                                :func:
#+begin_src emacs-lisp
  (defun my/try-recover-file (file)
    "Attempt to recover FILE from its autosave non-interactively.
    Returns t if recovery succeeds, Returns nil if recover-file
    signals an error, I.E. the file doesn't exist, the auto-save
    doesn't exist, or the auto-save is older than the file Note
    that if the file is currently open and modified any current
    changes to the file are unrecoverably lost."
    (interactive "FRecover File:")
    (cl-letf (((symbol-function 'yes-or-no-p) (lambda (&rest _) t)))
      (condition-case nil
          (recover-file file)
        (:success
         (message "recovered file: %s" file)
         t)
        ;; how is the auto save file not existing an error but it being out of date a user-error?
        ;; why are they not both user-errors, I'd really rather not catch all possible errors here.
        (error nil)
        (user-error nil))))
#+end_src
*** my/recover-from-autosave-list                                      :func:
#+begin_src emacs-lisp
(defun my/recover-from-autosave-list (list-file)
  "Recover all real files listed in LIST-FILE.
Skips entries that look like autosave files themselves.  Returns
t if any file was recovered (opened and buffer set to auto-save
content), or returns nil if none of the files had valid autosave
data.

Note that autosave lists always contain pairs of the original
file and the auto-save file. To be robust against changing the handling
of auto-save files this function *should* try to recover from the
explicitly listed auto-save files instead of determining where
the autosave should be based on the current configuration. This
function *doesn't* do that because the underlying recover-file
function doesn't support that."
  (interactive (list (read-file-name
              "Autosave List: "
              (file-name-directory auto-save-list-file-prefix)
              nil t ;; don't give default but require matching a file
              (file-name-nondirectory auto-save-list-file-prefix))))
  (unless (file-readable-p list-file)
    (error "file %s does not exist" list-file))
  (let ((recovered nil)
    (files-to-recover
     (with-temp-buffer
           (insert-file-contents list-file)
       (split-string (buffer-string) "\n" t))))
    
    (dolist (line files-to-recover)
      (let ((path (string-trim line)))
    (unless (auto-save-file-name-p
         (file-name-nondirectory path))
      (when (my/try-recover-file path)
        (setq recovered t)))))
    recovered))
#+end_src
**** DOC note about limitation of this function
Note that autosave lists always contain pairs of the original file and
the auto-save to be robust against changing the handling of
auto-save files this function *should* try to recover from the
explicitly listed auto-save files instead of determining where the
autosave should be based on the current configuration. This function
*doesn't* do that because the underlying recover-file function
doesn't support that.

*** my/process-all-autosave-lists                                      :func:
#+begin_src emacs-lisp
  (defun my/process-all-autosave-lists ()
    "Process all autosave list files in the auto-save-list directory.
  all files found with auto-save data (that is newer than file) are
  opened and recovered. All auto-save lists that do not reference
  any file that requires recovery are deleted.

  returns t if there was at least one autosave-list that was
  processed, nil otherwise.

  A message is generated for each file recovered and each stale
  autosave list deleted so it may be desirable to show the messages
  buffer if this returns true to show the user the list of
  operations."
    (let* ((prefix auto-save-list-file-prefix)
           (dir (file-name-directory prefix))
           (file-prefix (file-name-nondirectory prefix))
           (pattern (concat "^" (regexp-quote file-prefix)))
           (matches (directory-files dir t pattern)))
      (when matches
        (dolist (file matches)
          (unless (my/recover-from-autosave-list file)
            (delete-file file)
            (message "Deleted stale autosave list: %s" file)))
        t)))
#+end_src
*** process all autosaves on startup
~my/process-all-autosave-lists~ only deletes autosave list files that
don't contain any useful/current info and just opens buffers for files
with autosave data, I consider this a totally safe operation to run on
startup and the behaviour to re-open all buffers that were not saved
when closing last session is very useful behaviour.

#+begin_src emacs-lisp
  (add-hook 'emacs-startup-hook #'my/process-all-autosave-lists)
#+end_src

** keep autosave lists on exit                                         :func:

Stupid emacs stupid uneditable C code that runs after any hook I can
configure [[https://github.com/emacs-mirror/emacs/blob/5485bda52399a23d95ab593dcb748975ee0654d0/src/emacs.c#L2977][deletes the auto-save list]]! The comment is "we are exiting
emacs deliberately" but doesn't actually check that the exit_code
signals a success, I am so mad at this.

As a work around I will put a hook to unset the autosave list filename
so it can't remove it, very much depending on the C code not breaking
from me dropping the filename mid execution and just seeing it isn't a
string anymore so it won't try to delete and also that nothing tries
to add entries to it after my hook runs.

#+begin_src emacs-lisp
  (defun my/auto-save-then-stop-deletion-of-autosave-list-file ()
    "does an autosave then unsets `auto-save-list-file-name' to prevent
     emacs from deleting it on exit this is not the safest fix, a
    patch to the c code to remove the lines that delete the file
    would be preferable"
    (do-auto-save t)
    (setq auto-save-list-file-name nil))
  (add-hook 'kill-emacs-hook #'my/auto-save-then-stop-deletion-of-autosave-list-file 90)
#+end_src

*** TASK write emacs patch to not delete autosave list
:PROPERTIES:
:Effort:   2h
:END:
at some point I want to write a patch that just stops it from deleting
the autosave list instead of stripping the variable.

this urks me so much

** DONE save on close frame                                            :func:

rebind `handle-delete-frame` special binding [[https://superuser.com/a/328356/550312][SE answer reference]] which
is called when win+del is called.

Every time I close any frame I want to be prompted to save all
modified buffers, I don't care if another frame is open or not I just
want to save my work regularly.

#+NAME: my/close-frame
#+begin_src emacs-lisp
  (defun my/close-frame (event)
    "replacement for `handle-delete-frame' to prompt to save all
  modified buffers before killing the frame.
  This also always tries to delete the frame and does not try to
  exit emacs if it is the last frame, instead it will just fail
  which is fine for my usage with a server."
    (interactive "e")
    ;; posn-window returning a frame conditionally on details of the
    ;; event seems extremely fragile in this context but it is what the original uses.
    (let* ((frame (posn-window (event-start event))))
      (save-some-buffers)
      ;; if save-some-buffers errors from aborting this won't get run
      ;; also if the virtual frame was deleted or emacs was opened not
      ;; in the daemon this will just fail to delete the frame and
      ;; prevent using window manager to remove the frame.
      (delete-frame frame t)
      ))
  (define-key special-event-map [delete-frame] #'my/close-frame)
#+end_src
** save some buffers revert option
When closing a frame save-some-buffers gets called and I often want a
quick way to revert the buffer if I run a diff and it contains a
character I accidentally typed.

#+begin_src emacs-lisp
  (add-to-alist 'save-some-buffers-action-alist
  		?r ;; not clear on what exactly this does but ? prefix is how the source code denotes the characters
  		      ;; second is function to call when the action is taken
  		      (list (lambda (buf) (with-current-buffer buf (revert-buffer nil t)))
  		      (purecopy "revert buffer")))
#+end_src


* display buffer logic
Display "actions" take the form of ~(FUNC . ALIST)~ where
- =FUNC= is a function or list of functions to be called to displaly a
  buffer.
- =ALIST= is a list of perameters used by the display functions to
  decide what to do.

see [[help:display-buffer][display-buffer help]] for extensive documentation on all the
settings, the main thing I want to mention is that given how lists are
stored and how ~cons~ cells work, a sequence of ~(COND . (FUNC . ALIST))~ is equivelent to just a plain list of ~(COND FUNC . ALIST)~ (and the entries of the ALIST can be written out without seperation by the period)

*** is-buffer-easily-quittable :func:localvar:
helper function for determining modes that should be allowed to open
in split window.

#+begin_src emacs-lisp
    (defvar my/quit-functions (list #'quit-window #'calendar-exit)
      "list of functions that logically represent quit the current window")
    (defun is-buffer-easily-quittable (buffer _arg)
      "returns true if the given buffer has q assigned to close the window"
      (with-current-buffer buffer
        (memq (key-binding "q" t) my/quit-functions)))
#+end_src
** display-buffer-base-action and display-buffer-overriding-action
Assuming no applicable overrides, this describes the logic for
handling displaying a buffer. The basic logic is to follow these
(implied "else check the next one")
- [[(reuse-window)]] if there is already a window showing the buffer use
  that (if it is in a non selected frame bring focus to the frame)
  - [[help:org-agenda-prepare-window][org display logic]] doesn't have an option to just show the agenda
    according to generic display buffer configurations, it always
    provides its own display function so I have to put this in the
    =overriding= option to get around it.
- [[(use-some-window)]] if there are multiple frames open, show the buffer in another frame
  (enable split view workflow) 
- [[(full-frame)]] otherwise (there is only one frame open) get the new buffer to take
  up the full frame closing any other windows.

There is some complications from the implicit virtual frame created by
the daemon, =reuse-window= does seem to ignore it but
=use-some-frame='s default predicate includes the virtual frame so we
need to override it to filter to only frames on the graphical display.

#+begin_src emacs-lisp -r
  (setopt display-buffer-overriding-action
  	'((display-buffer-reuse-window))) ;(ref:reuse-window)
  (setopt display-buffer-base-action
  	`((display-buffer-use-some-frame ;(ref:use-some-window)
  	   display-buffer-full-frame)    ;(ref:full-frame)
  	  ;; rest of elements are items in the ALIST
  	  (inhibit-same-window . nil)
  	  ;; used by reuse-window to check windows already open
  	  (reusable-frames . visible)
  	  ;; used by use-some-frame
  	  (frame-predicate . ,(lambda (frame)
  				(and
  				 (not (eq frame (selected-frame)))
  				 (frame-parameter frame 'display))))
  	  ))
#+end_src
** TASK display-buffer-alist
Overrides for display logic:
- right clicking on todo item in org agenda prevents it from overriding the agenda window which is very dumb and annoying. I set a rule to reset =inhibit-same-window= to nil for any file that doesn't have asterixs, I.E. normal files.
- buffers that are "easy to quit" should split the frame to show the buffer in a new window.

I would like to improve this though, opening normal files should
prioritize putting in the top window if there are multiple and opening
special buffers should prioritize bottom one. The goal being to less
often end up with a not easily quitable buffer open on the bottom and
need to manually close it to get back to full screen and also prevent
opening info and help from splitting into 3 windows.

Also the validation that ~setopt~ does on the condition says it has to be a regexp or a function and doesn't support the other structures that [[help:buffer-match-p][buffer-match-p]] indicates it supports. (and [[help:display-buffer-alist][this variables docs]] directly says the condition gets passed to that function) So we use ~setq~ for this one instead of setopt to suppress the warning we would otherwise get.

#+begin_src emacs-lisp
  (setq display-buffer-alist
  	'(
  	  ;;let normal files reuse the same window always
  	  ((not "^\\*.+\\*$") nil (inhibit-same-window . nil))
  	  ;; easily closable or temporary buffers split window
  	  ((or is-buffer-easily-quittable
  	       "^\\*Org Select\\*$"
  	       "^\\*Org Links\\*$"
  	       )
  	   (display-buffer-below-selected))
  	  ))
#+end_src

* Org
- org-agenda-skip-scheduled-repeats-after-deadline
- org-agenda-prefix-format
  - breadcrumbs?? shows headers?

** load habit module
See [[info:org#Tracking your habits][org#Tracking your habits]], effectively having a scheduled with a
repeater and a property =:STYLE: habit= makes it only show up in the
agenda for today and not in the future. For that to happen though we
have to load the habit module.
#+begin_src emacs-lisp
  (add-to-list 'org-modules 'habit t) ;; apparently appending to end is important?
#+end_src
** keywords and todo behaviour
My main workflow with org agenda is to label lots of possible tasks as
things I could work on, then every day move some to TODO to work on
them. Also added SOON which has same meaning as task but label as good
idea for next step or otherwise worth working on soon independent of
it being important or high priority.

I also define DEFERRED to mean "I don't intend to work on this" but
still describes an actionable thing, potentially it is something I
want to do but need more evidence/information about it to actually
make any progress on it.

#+begin_src emacs-lisp
  (setopt org-todo-keywords
  	'((sequence "TASK(t)" "SOON(s)" "TODO(n!)"
  		    "|"
  		    "DONE(~@/@)" "DEFERRED(d@)")))
#+end_src
*** dependencies
Prevent marking items as done if they have unfinished children (either
sub tasks or checkboxes) as accidentally marking something as
completed is highly undesirable.

However, this also controls the agenda view logic to mark "blocked"
tasks so I need to not dim tasks that just have checkboxes as those
mostly use to mean "task is to make progress with these steps" I would
really like to prevent switching to done if there are incomplete
checkboxes but not consider blocked in the agenda view but unsure how
to do that.

#+begin_src emacs-lisp
  (setopt org-enforce-todo-dependencies t)
  ;; low priority TODO: see if there is a not awful way to set this to t
  ;; when generating agenda view and nil when the user operation
  ;; matters.
  (setopt org-enforce-todo-checkbox-dependencies nil)
#+end_src
*** repeat tasks go to TODO state
tasks that have a repeat deadline/scheduled are marked as done should
go back to the state they were in before. the [[help:org-todo-repeat-to-state][help on this variable]]
indicates it supports this behaviour but doesn't explain how, a foot
note in [[info:org#Repeated tasks][this info page]] indicates setting it to ~t~ is how this is done.
#+begin_src emacs-lisp
  (setopt org-todo-repeat-to-state t)
#+end_src

*** TASK add colours to todo keywords
[[help:org-todo-keyword-faces]]
** capture
see [[help:org-capture-templates][org-capture-templates]] for format, this file contains [[#TechGripes][Tech gripes]],
another file (preferably an inbox) will need a section with the ID
[[id:RandomThoughts][RandomThoughts]].
#+begin_src emacs-lisp
  (setopt org-capture-templates
  	'(("c" "clocked task note" plain (clock) "")
  	  ("z" "quick thought to revisit at some point" item (id "RandomThoughts") "")
  	  ("e" "emacs/tech gripe" checkitem (id "TechGripes") "")
  	  ("j" "Journal entry" entry (file+olp+datetree "journal.org") "")
  	  ("i" "Inbox Task" entry (file "inbox.org") "* TASK ")
  	  ))
#+end_src

*** DEFERRED look into templates and variables
*** TASK report bug for [[help:org-capture-fill-template]]
use of save-window-excursion is extremely stupid and should just use
with-current-buffer. As written with my display buffer logic it opens
the template in a different frame bringing focus there, then closes it
and opens a differnet buffer for user editing.

The docs of save-window-excursion directly indicate that it can
introduce bugs like this, and if the goal is to just fill out the
template there is no reason to play with window configs at all. At
minimum it should be trying to open in the same window then resetting
it, not opening in a different window.
*** TASK capture prefix/open location
need a mechanism to open location of capture, either from the capture
buffer or to do equivelent of =C-u C-u M-x org-capture= to open last
recorded capture.
*** TASK setup template for appointments / events
file to journal with timestamp, prompt for date and time range
** TASK refile
need to add logic to offer more useful refile targets:
- [ ] emacs gripe should ideally be able to go as subtask of any subheading like org/capture etc
- [ ] journal entry should be able to be refiled to previous date
- [ ] 
** agenda view
I primarily want a view that shows the agenda and a list of tasks,
where I want the ability to switch between showing all tasks to only
showing TODOs.

Using the default "t" view for global list of all todos is sufficient
and then switching to my custom view that shows both agenda and TODO
items is mostly fine, the issue is that I kind of need a keybinding to
switch between them and I don't particularly want to bind a key just
to switch the view. there is already logic setup to pass a prefix to
the 'r' key when viewing the agenda but this messes up the week view,
changing the number of days etc and the number associated with
different todo keywords is very confusing.

So insteaed see [[*org capture + org agenda][org capture + org agenda]] for the function and find its
entry in the keybinding table, I use a keybind to give a prompt like
org-capture but also shows agenda views so I can switch between them
easily.

#+begin_src emacs-lisp
  ;; start on sunday
  (setopt org-agenda-start-on-weekday 0)
  ;; show 2 weeks by default
  (setopt org-agenda-span 14)
  (setopt org-agenda-custom-commands
  	'(("n" "Agenda and todos"
  	   ((todo "TODO")
  	    (agenda "")))))
#+end_src

Also a key part about this system is being able to push off tasks so
they won't appear in the global list for a while, my current working
plan is to schedule TASK items to push them off, this is maybe not the
best plan but I will come back to edit this text with different config
if I come to that conclusion.

#+begin_src emacs-lisp
  (setopt org-agenda-todo-ignore-scheduled 'future)
#+end_src
*** add seperator to todolist categories :func:
this function was written with the help of chatgpt, takes a string
with properties and inserts seperators between groups with common
prefix. To be used as advice on ~org-agenda-finalize-entries~ to insert seperators between categories

I'd somewhat prefer to put the actual wrapper in a lambda but adding
advice to a symbol seems more likely to prevent adding the advice
multiple times.
#+begin_src emacs-lisp
  (defun my/group-lines-by-prefix-with-separator (text)
    "Insert separators between groups of lines with same prefix before colon in TEXT.
  Preserves text properties. Returns a new propertized string."
    (let* ((lines (split-string text "\n"))
           (result '())
           (last-prefix nil))
      (dolist (line lines)
        (let ((prefix (when (string-match "^\\([^:\n]+\\):" line)
                        (match-string 1 line))))
          ;; Insert separator if prefix changes
          (when (and last-prefix prefix (not (string= prefix last-prefix)))
            (push (propertize "---\n") result))
          ;; Push the current line and newline
          (push line result)
          (push "\n" result)
          (setq last-prefix prefix)))
      ;; Join and preserve properties via concat
      (apply #'concat (nreverse result))))

  (defun my/org-agenda-finalize-entries-around (orig-fn entries type &rest args)
    "Wrap `org-agenda-finalize-entries', modifying result if TYPE is todo."
    (let ((result (apply orig-fn entries type args)))
      (if (eq type 'todo)
          (my/group-lines-by-prefix-with-separator result)
        result)))

  (advice-add #'org-agenda-finalize-entries :around #'my/org-agenda-finalize-entries-around)
#+end_src
*** TASK hide tasks scheduled for future from agenda view (but not TODOs)
once I have enough tasks that I want to reschedule them just to delay
me thinking about working on them and not as 'i will work on them at
this date' I will probably want to ensure that tasks don't show up in
the agenda view but TODOs still should probably.
** agenda files
All files under =~/org= will hold all of the agenda files, as well as this file under dotfiles.

In the sorting algorithm, =category-keep= preserves the order as
specified in the list of agenda files. As such this list redundantly
lists a number of files in the org directory to override their order
in the list of todo items. the directory itself specifies all other
files in the folder that aren't listed by name (at least I hope that
is how it is interpreted, if not I will write code to grab all the
files but would rather not if I can help it).
#+begin_src emacs-lisp
  (setopt org-directory "~/org")
  ;; probably not used as I specify a file for all capture targets but useful to have in case.
  (setopt org-default-notes-file "~/org/inbox.org")
  (setopt org-agenda-files
  	(list
  	 org-default-notes-file
  	 "work.org"
  	 "journal.org"
  	 "upkeep.org"
  	 org-directory
  	 "projects.org"
  	 "turris.org"
  	 "backups.org"
  	 "~/src/dotfiles/emacsconfig.org"
  	 ))
#+end_src
*** DONE [#A] edit agenda files list for category order
[[help:org-agenda-sorting-strategy]] defines an option for "category-keep"
which preserves the order of files in the agenda files list, so
specifying the files explicitly in the order they should show up in
the global todo list would be helpful here.
** sorting strategy

See [[help:org-agenda-sorting-strategy]]

Intention is to strictly seperate tasks by category, then by state
(TASK/SOON/TODO) then by other criteria. This is to help me try to
choose items from each category to work on. specifically the sorting is:
- habit-up puts all the habit items at the very top of the list no matter which file they come from
- category-keep sorts by category according to the order defined by [[*Agenda Files]]
- todo-state-down puts later todo states first (TODO), followed by SOON followed by TASK etc. this makes it easy to see which tasks I already have assigned
- priority-down shows high priority tasks first
- deadline-up shows sooner deadlines before others
- effort-up shows tasks with explicitly marked low effort first, up to high explicit effort then no effort after according to [[help:org-agenda-sort-noeffort-is-high]]

Agenda entries are sorted using the default order which matters as I agree with this sorting:
- habit-down to push habit entries in the agenda view to the bottom
- time-up so entries with explicit times are sorted as desired in an agenda view
- urgency-down which uses a not particularly thoroughly documented
  process with priority and scheduled and deadlines. [[info:org#Sorting of agenda items][org#Sorting of
  agenda items]] is the best description I can find for it but in the
  agenda view I don't particularly care. Is largely priority-down + some deadline and scheduling tie breakers.
- category-keep, in case of agenda items that are totally equal they
  can be sorted by category but this is much less important in the
  agenda view.

the other views =tags= and =search= which I don't typically use I also
restate the default value as the agenda but because it is easier than
any alternative not because I care about it.

Also note that the custom value checking requires the order be
agenda,todo,tags,search. I am unsure if it actually relies on the
order or it just couldn't be bothered to type it as an "every key is
required" alist.
#+begin_src emacs-lisp
    (setopt org-agenda-sorting-strategy
    	  '((agenda time-up urgency-down category-keep)
  	  (todo habit-up category-keep todo-state-down priority-down deadline-up effort-up)
    	    (tags urgency-down category-keep)
    	    (search category-keep)))
    	  
#+end_src

** TASK get state change notes to go to journal
see [[help:org-after-note-stored-hook]], I suspect I can introspect data
about task state changes and record it to my journal as that is where
I'd really like those notes. I'd really like for actions like
TASK->TODO and TODO->DONE to be logged in the day's info and possibly
clocking info and get into the habit of looking at the journal entry
and writing up a bit about my day every day.

**  caldav
Few options for icalendar export, to do full sync with phone I will
need to setup import logic as well.
#+begin_src emacs-lisp
  ;;; could use 'all but I'd like to suppress TASK items
  (setopt org-icalendar-include-todo '("TODO" "DONE"))

  (setopt org-icalendar-categories '(all-tags))

  (setopt org-icalendar-store-UID t)
#+end_src

See [[info:org#iCalendar Export][org#iCalendar Export]], relevant org properties are LOCATION,
TIMEZONE, CLASS. If SUMMARY or DESCRIPTION are present in property
drawer they are used instead of node body and headline.

I don't think the default exporter retains parent/child relations
which tasks.org app does make use of.

Also it would be nice to have it export checkbox lists as subtasks
that can be checked off but dealing with unique IDs for those would be
complicated if they can be rearranged or deleted.

*** DEFERRED old code for caldav, import ical data
this is outdated code from old init file, tangle is disabled so it is
not output to new init file. Syncing the org agenda with my phone is
very much on my mind so I will naturally try to come back to this.

#+begin_src emacs-lisp :tangle no
  ;(require 'org-caldav)
  ;(setopt org-caldav-url "http://localhost:8080/user/calendars")
  ;(setopt org-caldav-calendar-id "calendar")

  ;;; TODO: set the inbox and files based on agenda files, it may
  ;;; honestly default to read the first/last value from agenda files if
  ;;; not set

  ;; Org filename where new entries from calendar stored
  ;(setopt org-caldav-inbox "~/Sync/cal.org")

  ;; Additional Org files to check for calendar events
  ;(setopt org-caldav-files '("~/Sync/work.org"))
  ;; and set the org agenda to also have those files
  (setopt org-agenda-files '("~/Sync/work.org"
                           "~/Sync/cal.org"))

  ;; Usually a good idea to set the timezone manually
  (setopt org-icalendar-timezone "America/Toronto")

  ;; sync todos as well.
  (setopt org-icalendar-include-todo 'all)
       ; org-caldav-sync-todo t)
  ;; creates SCHEDULED timestamp from DEADLINE
  ;; (setq org-caldav-todo-deadline-schedule-warning-days t)
#+end_src



** TASK checkbox vs task refile and indent config
~org-do-premote~ and ~org-do-demote~ should maybe have dedicated
bindings instead of relying on M-<left> to do it or possibly
navigation.

Ideally demoting a heading that is already a child of the lowest rank
could convert it to a list item and premoting a list item could
convert it to a child subheading, I'd want the functionality to move
the item around so premoting a list item in the middle of a list moves
it to the bottom of the list and demoting a subheading moves it to a
list at its parent's root before any siblings.

detection of the content to move with a list item to move with it and
similarly how to format the content of the subheading (could just fail
if there is more than just plain text or a list). 

* Programming
** Guix/guile development
*** TASK read [[info:emacs-guix#Top][emacs-guix#Top]]
** describe symbol at point                                            :func:
binding H-? to describe symbol at point, either using eglot's hover
logic or elisps ~describe-symbol~.  Heavily inspired by [[https://github.com/joaotavora/eglot/discussions/1034#discussioncomment-3653005][this]] which in
turn is inspired by [[help:eglot-hover-eldoc-function][eglot-hover-eldoc-function]]. I implemented this
version to reuse the function instead of restating basically all of
its logic.
#+begin_src emacs-lisp
  (require 'eglot)
  (defun eglot-describe-thing-at-point ()
    "calls lsp hover provider and writes details to help buffer"
    (interactive)
    (eglot-hover-eldoc-function (lambda (info &rest _stuff)
  				(with-help-window (help-buffer)
  				  (with-current-buffer (help-buffer)
  				    (insert info))))))
  (keymap-set eglot-mode-map "H-?" #'eglot-describe-thing-at-point)
  (keymap-set lisp-mode-shared-map "H-?"
  	    ;; in lisp files call describe-symbol directly with symbol at point
  	      (lambda (symbol) (interactive (list (symbol-at-point))) (describe-symbol symbol)))
#+end_src
** eglot server logic
#+begin_src emacs-lisp
  (defun my/eglot-server-guix-shell-wrapper (guix-packages command &optional _installer)
    "wrapper around guix shell invokation for eglot, detects
  manifest.scm in root of project and includes it in the guix shell
  if found.

  the 3rd argument INSTALLER denotes a command that may be
  neccesary to use the server but is unused in this implementation."
    (lambda (&optional _interactive)
      ;; TODO figure out a way to write this that is DRY, need several
      ;; variables to detect whether manifest exists and if it does just
      ;; want to insert some options into command
      (if-let ((pr (project-current))
  	     (root (project-root pr))
  	     (manifest-file (file-name-concat root "manifest.scm"))
  	     (manifest-exists (file-exists-p manifest-file)))
  	`("guix" "shell" ,@guix-packages "--manifest" ,manifest-file "--" ,@command)
        `("guix" "shell" ,@guix-packages "--" ,@command))))
  (add-to-alist 'eglot-server-programs
  	      '((js-mode :language-id "javascript")
                  (js-ts-mode :language-id "javascript")
                  (tsx-ts-mode :language-id "typescriptreact")
                  (typescript-ts-mode :language-id "typescript")
                  (typescript-mode :language-id "typescript"))
  	      (my/eglot-server-guix-shell-wrapper
  	       '("node")
  	       '("npx" "typescript-language-server" "--stdio")
  	       '("npm" "install" "-g" "typescript-language-server")))
  (add-to-alist 'eglot-server-programs
  	      '(python-mode python-ts-mode)
  	      (my/eglot-server-guix-shell-wrapper
  	       '("python-lsp-server")
  	       '("pylsp")))
  	      
#+end_src
** eglot documentation logic
Apparently users of eglot seem to think that displaying hover tooltip
is useful in the middle of function signature details instead of
exposing that similar to help utility.

This is rediculous, eldoc is setup well for signature details and the
emacs help buffer is useful for documentation strings. Why shove both in eldoc??

#+begin_src emacs-lisp
  (add-hook 'eglot-managed-mode-hook
          (lambda ()
            (setq eldoc-documentation-functions
  		(remove #'eglot-hover-eldoc-function
  			eldoc-documentation-functions))))
#+end_src

** eldoc echo behaviour
When an LSP server is setup, [[help:eldoc-mode][eldoc-mode]] shows documentation in the
echo area, by default it spreads the window way too large so configure it to show much less detail.

See [[info:emacs#Programming Language Doc][emacs#Programming Language Doc]]
#+begin_src emacs-lisp
  ;; don't give instructions message in echo area if truncated
  (setopt eldoc-echo-area-display-truncation-message nil)
  ;; limit to 2 lines in echo area
  (setopt eldoc-echo-area-use-multiline-p 2)
#+end_src

* Misc
** DEFERRED encryption passphrase cache
Don't actually know what this does, copied from morgan's config and haven't used gpg stuff in emacs in ages so unsure what specifically it does.
#+begin_src emacs-lisp :tangle no
(setopt plstore-cache-passphrase-for-symmetric-encryption t)
#+end_src

** safe-local-variable-values
this is a bunch of local variables that guix uses that are not considered implcitly safe, I trust all of them.

The way I generated this is by making the init.el editable and when opening a file under guix and it prompts about local variables there is an option to add them which sets a field for =custom= to set them to safe. If guix changes their variables I should probably let this use the custom syntax and copy it back here instead of rewriting it into setopt.

#+begin_src emacs-lisp
(setopt
 safe-local-variable-values
   '((geiser-insert-actual-lambda)
     (eval with-eval-after-load 'tempel
	   (if
	       (stringp tempel-path)
	       (setq tempel-path
		     (list tempel-path)))
	   (let
	       ((guix-tempel-snippets
		 (concat
		  (expand-file-name "etc/snippets/tempel"
				    (locate-dominating-file default-directory ".dir-locals.el"))
		  "/*.eld")))
	     (unless
		 (member guix-tempel-snippets tempel-path)
	       (add-to-list 'tempel-path guix-tempel-snippets))))
     (eval with-eval-after-load 'git-commit
	   (add-to-list 'git-commit-trailers "Change-Id"))
     (eval add-to-list 'completion-ignored-extensions ".go")
     (eval setq-local guix-directory
	   (locate-dominating-file default-directory ".dir-locals.el"))
     (eval with-eval-after-load 'yasnippet
	   (let
	       ((guix-yasnippets
		 (expand-file-name "etc/snippets/yas"
				   (locate-dominating-file default-directory ".dir-locals.el"))))
	     (unless
		 (member guix-yasnippets yas-snippet-dirs)
	       (add-to-list 'yas-snippet-dirs guix-yasnippets)
	       (yas-reload-all))))
     (geiser-repl-per-project-p . t)
     (eval modify-syntax-entry 126 "'")
     (eval modify-syntax-entry 36 "'")
     (eval modify-syntax-entry 43 "'")
     (eval progn
	   (require 'lisp-mode)
	   (defun emacs27-lisp-fill-paragraph
	       (&optional justify)
	     (interactive "P")
	     (or
	      (fill-comment-paragraph justify)
	      (let
		  ((paragraph-start
		    (concat paragraph-start "\\|\\s-*\\([(;\"]\\|\\s-:\\|`(\\|#'(\\)"))
		   (paragraph-separate
		    (concat paragraph-separate "\\|\\s-*\".*[,\\.]$"))
		   (fill-column
		    (if
			(and
			 (integerp emacs-lisp-docstring-fill-column)
			 (derived-mode-p 'emacs-lisp-mode))
			emacs-lisp-docstring-fill-column fill-column)))
		(fill-paragraph justify))
	      t))
	   (setq-local fill-paragraph-function #'emacs27-lisp-fill-paragraph))))

#+end_src
